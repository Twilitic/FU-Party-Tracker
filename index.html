<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fabula Ultima Party Sheet</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
    
    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/9.6.7/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.7/firebase-firestore-compat.js"></script>
    
    <!-- Fabula Ultima Skill Library -->
    <script src="skill_library.js"></script>

    <style>
        :root {
            --background-blue: #000080;
            --window-bg: #1a1a5c;
            --border-light: #ffffff;
            --border-dark: #808080;
            --text-yellow: #ffff00;
            --text-cyan: #00ffff;
            --hp-color: #32cd32; --hp-temp-color: #90ee90;
            --mp-color: #4169e1; --mp-temp-color: #add8e6;
            --ip-color: #ff8c00; --ip-temp-color: #ffd700;
            --crisis-color: #ef4444;
        }

        body {
            font-family: 'Share Tech Mono', monospace;
            background-color: var(--background-blue);
            color: white;
            image-rendering: pixelated;
            background-size: cover;
            background-position: center;
            overflow: hidden;
        }

        .jrpg-window {
            background-color: var(--window-bg);
            border: 4px solid;
            border-image: linear-gradient(to bottom, var(--border-light), var(--border-dark)) 1;
            box-shadow: 0 0 0 4px #000;
            padding: 0.5rem;
        }
        @media (min-width: 768px) { .jrpg-window { padding: 0.75rem; } }

        .progress-bar-container { background-color: #000; border: 2px solid var(--border-dark); height: 20px; width: 100%; cursor: pointer; position: relative; }
        .progress-bar { height: 100%; transition: width 0.3s ease-in-out, background-color: 0.3s ease-in-out; position: absolute; left: 0; top: 0; }
        .menu-item, .action-button { -webkit-user-select: none; -ms-user-select: none; user-select: none; position: relative; }
        .menu-item:hover, .action-button:hover { background-color: #3a3a8c; cursor: pointer; }
        .truncate-on-hover { flex-grow: 1; min-width: 0; overflow: hidden; white-space: nowrap; position: relative; }
        .truncate-on-hover > span { display: inline-block; }
        .status-icon { width: 24px; height: 24px; border-radius: 4px; padding: 2px; background-color: rgba(0,0,0,0.5); cursor: pointer; flex-shrink: 0; }
        .status-icon svg { opacity: 0.3; }
        .status-icon.active svg { opacity: 1; }
        .modal-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); display: flex; justify-content: center; align-items: center; z-index: 100; }
        .modal-content-full { width: 100%; height: 100%; }
        .modal-content::-webkit-scrollbar, .scrollable-menu::-webkit-scrollbar { width: 8px; }
        .modal-content::-webkit-scrollbar-track, .scrollable-menu::-webkit-scrollbar-track { background: #000; }
        .modal-content::-webkit-scrollbar-thumb, .scrollable-menu::-webkit-scrollbar-thumb { background-color: var(--border-dark); border: 2px solid var(--border-light); }
        input, select, textarea { background-color: #000; border: 2px solid var(--border-light); color: white; padding: 0.25rem; font-family: 'Share Tech Mono', monospace; width: 100%; }
        input[type="color"] { padding: 0; border: none; height: 30px; width: 50px; }
        input[type="checkbox"] { width: auto; }
        .portrait-container { position: relative; }
        .portrait-container.crisis::after { content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(255, 0, 0, 0.3); pointer-events: none; animation: crisis-flash 1.5s infinite; }
        @keyframes crisis-flash { 0%, 100% { box-shadow: 0 0 8px 4px rgba(255,0,0,0.5); } 50% { box-shadow: 0 0 4px 2px rgba(255,0,0,0.2); } }
        .breadcrumb-item { cursor: pointer; }
        .breadcrumb-item:hover { text-decoration: underline; }
        .draggable.dragging { opacity: 0.5; background: #2a2a7c; }
        .drop-indicator { height: 2px; background-color: var(--text-yellow); margin: -1px 0; display: none; }
        .drop-target-category { background-color: rgba(255, 255, 0, 0.2); }
        .collapse-toggle { cursor: pointer; padding-right: 0.5rem; color: var(--text-cyan); }
        .locked-item { cursor: not-allowed; }
        .offline-banner {
            background-color: var(--ip-color);
            color: black;
            text-align: center;
            padding: 0.25rem;
            font-weight: bold;
            position: sticky;
            top: 0;
            z-index: 200;
        }
        .modal-header-draggable { cursor: move; }
    </style>
</head>
<body>

    <!-- Session Management UI (Shown on Load) -->
    <div id="session-container" class="min-h-screen w-screen p-4 flex justify-center items-center">
        <div class="jrpg-window w-full max-w-md text-center">
            <h1 class="text-2xl text-yellow-300 mb-4">Fabula Ultima Party Tracker</h1>
            <p class="mb-6">Join a collaborative online session or use in offline mode.</p>
            <div class="space-y-4">
                <button id="create-party-btn" class="jrpg-window !p-2 action-button w-full">Create New Online Party</button>
                <div class="flex items-center gap-2">
                    <hr class="flex-grow border-gray-500"><span class="text-gray-400">OR</span><hr class="flex-grow border-gray-500">
                </div>
                <input type="text" id="party-id-input" placeholder="Enter Party ID" class="text-center">
                <button id="join-party-btn" class="jrpg-window !p-2 action-button w-full">Join Online Party</button>
                 <div class="flex items-center gap-2">
                    <hr class="flex-grow border-gray-500"><span class="text-gray-400">OR</span><hr class="flex-grow border-gray-500">
                </div>
                <button id="offline-mode-btn" class="jrpg-window !p-2 action-button w-full bg-gray-700">Use Offline Mode</button>
            </div>
             <p id="session-error" class="text-red-500 mt-4 h-4"></p>
        </div>
    </div>
    
    <!-- Main App UI (Hidden on Load) -->
    <div id="app-container" class="min-h-screen w-screen p-2 md:p-4 flex-col hidden">
        <div id="offline-banner" class="offline-banner hidden">OFFLINE MODE - Data is not being synced</div>
        <div id="status-panels" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-2 md:gap-4 flex-shrink-0"></div>
        <div id="command-menus" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-2 md:gap-4 mt-2 md:mt-4 flex-grow min-h-0"></div>
        <div id="modal-container"></div>
        <div class="absolute bottom-2 right-2 flex gap-2">
             <button data-action="edit-mode-toggle" id="edit-mode-toggle" class="jrpg-window !p-2 action-button">Edit</button>
             <button data-action="open-system-menu" class="jrpg-window !p-2 action-button">System</button>
        </div>
    </div>


    <script>
    window.onload = () => {
        // --- FIREBASE SETUP ---
        const firebaseConfig = {
            apiKey: "AIzaSyD73IhU0asC807BKVif9t6U9hIryDJlLNY",
            authDomain: "f-u-party-tracker.firebaseapp.com",
            projectId: "f-u-party-tracker",
            storageBucket: "f-u-party-tracker.appspot.com",
            messagingSenderId: "375233304595",
            appId: "1:375233304595:web:c306cc40667f84b86987e6"
        };
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        let partyId = null;
        let isOfflineMode = false;
        let unsubscribeFromParty = null;
        let saveDataTimeout = null;

        // --- STATE MANAGEMENT ---
        const AppState = { party: [], settings: { backgroundUrl: '' } };
        const LocalUIState = { 
            activeMenus: [ {path:[]}, {path:[]}, {path:[]}, {path:[]} ], 
            isEditMode: false, 
            activeModal: null, 
            settings: { volume: 0.5, muted: false, fontSize: 'md' },
            spellLibrary: []
        };
        
        // --- CONSTANTS & DEFINITIONS ---
        const FONT_SIZES = { sm: 'text-base', md: 'text-lg', lg: 'text-xl', xl: 'text-2xl' };
        const PRESET_ITEMS = ["Remedy", "Elixir", "Tonic", "Magic Tent"];
        const STATUS_EFFECTS = {
            slow: { name: 'Slow', color: '#60a5fa', icon: 'M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z' },
            dazed: { name: 'Dazed', color: '#facc15', icon: 'M10.788 3.21c.448-1.077 1.976-1.077 2.424 0l2.082 5.007 5.404.433c1.164.093 1.636 1.545.749 2.305l-4.116 3.986 1.518 5.671c.28 1.136-.954 2.033-1.96 1.425L12 18.354 7.373 21.18c-1.006.608-2.24-.289-1.96-1.425l1.518-5.671-4.116-3.986c-.887-.76-.415-2.212.749-2.305l5.404-.433 2.082-5.006z' },
            weak: { name: 'Weak', color: '#a3a3a3', icon: 'M12 4v16m-6-6l6 6 6-6' },
            shaken: { name: 'Shaken', color: '#6ee7b7', icon: 'M3 10l4 4 4-8 4 8 4-4' },
            poisoned: { name: 'Poisoned', color: '#a855f7', icon: 'M12,2C6.477,2,2,6.477,2,12s4.477,10,10,10s10-4.477,10-10S17.523,2,12,2z M9.5,8C10.328,8,11,8.672,11,9.5S10.328,11,9.5,11 S8,10.328,8,9.5S8.672,8,9.5,8z M14.5,8c0.828,0,1.5,0.672,1.5,1.5S15.328,11,14.5,11S13,10.328,13,9.5S13.672,8,14.5,8z M12,18 c-2.209,0-4-1.791-4-4h8C16,16.209,14.209,18,12,18z' },
            enraged: { name: 'Enraged', color: '#ef4444', icon: 'M12.94,2.62C11.6,2.22,10.15,2,8.5,2C5.46,2,3,4.46,3,7.5c0,1.99,1.04,3.73,2.62,4.78C5.22,13.4,5,14.69,5,16v1 c0,1.1,0.9,2,2,2h7c1.1,0,2-0.9,2-2v-1c0-1.31-0.22-2.6-0.62-3.72C17.96,11.23,19,9.49,19,7.5C19,5.85,18.78,4.4,18.38,3.06 C16.92,4.98,14.77,6,12.5,6c-1.55,0-3.04-0.48-4.38-1.38C8.96,3.7,9.81,3,10.77,2.44C11.53,2.83,12.25,3.09,12.94,2.62z' }
        };
        const ATTRIBUTES = ['DEX', 'MIG', 'INS', 'WLP'];
        const DICE = ['d6', 'd8', 'd10', 'd12'];
        const COST_TYPES = ['None', 'HP', 'MP', 'IP', '1/3 Current HP'];
        const DAMAGE_TYPE_DATA = {
            'Physical': { color: '#d1d5db', svg: '<path stroke-linecap="round" stroke-linejoin="round" d="M13.5 4.5 21 12m0 0-7.5 7.5M21 12H3" />' },
            'Air': { color: '#a7f3d0', svg: '<path stroke-linecap="round" stroke-linejoin="round" d="M12 19.5v-15m0 0l-6.75 6.75M12 4.5l6.75 6.75" />' },
            'Bolt': { color: '#fef08a', svg: '<path stroke-linecap="round" stroke-linejoin="round" d="m3.75 13.5 10.5-11.25L12 10.5h8.25L9.75 21.75 12 13.5H3.75Z" />' },
            'Dark': { color: '#c4b5fd', svg: '<path stroke-linecap="round" stroke-linejoin="round" d="M21.752 15.002A9.718 9.718 0 0 1 18 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 0 0 3 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 0 0 9.002-5.998Z" />' },
            'Earth': { color: '#fca5a5', svg: '<path stroke-linecap="round" stroke-linejoin="round" d="M15.042 21.672 13.684 16.6m0 0-2.51 2.225.569-9.47 5.227 7.917-3.286-.672ZM12 2.25V4.5m5.832.168-1.182 1.95M21.75 12h-2.25M17.832 17.332l-1.182-1.95M5.832 17.332 7.014 15.38M3 12H5.25m1.832-5.332L7.014 8.62m12 .528L16.986 9.38" />' },
            'Fire': { color: '#fdba74', svg: '<path stroke-linecap="round" stroke-linejoin="round" d="M15.362 5.214A8.252 8.252 0 0 1 12 21 8.25 8.25 0 0 1 6.038 7.047 8.287 8.287 0 0 0 9 9.608a8.981 8.981 0 0 1 3.362-3.797A8.33 8.33 0 0 1 15.362 5.214Z" />' },
            'Ice': { color: '#a5f3fc', svg: '<path stroke-linecap="round" stroke-linejoin="round" d="M12 4.5v15m7.5-7.5h-15" />' },
            'Light': { color: '#fde047', svg: '<path stroke-linecap="round" stroke-linejoin="round" d="M12 3v2.25m6.364.386-1.591 1.591M21 12h-2.25m-.386 6.364-1.591-1.591M12 18.75V21m-4.773-4.227-1.591 1.591M5.25 12H3m4.227-4.773L5.636 5.636M15.75 12a3.75 3.75 0 1 1-7.5 0 3.75 3.75 0 0 1 7.5 0Z" />' },
            'Poison': { color: '#f0abfc', svg: '<path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 0 1 1.242 7.244l-4.5 4.5a4.5 4.5 0 0 1-6.364-6.364l1.757-1.757m13.35-.622 1.757-1.757a4.5 4.5 0 0 0-6.364-6.364l-4.5 4.5a4.5 4.5 0 0 0 1.242 7.244" />' },
            'No Affinity': { color: '#ffffff', svg: '<path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126ZM12 15.75h.007v.008H12v-.008Z" />' },
        };
        const TARGETING_TYPES = ['1 Target', '2 Targets', '3 Targets', 'All Targets', 'All Allies', 'Self'];
        const EFFECT_TYPES = {
            healing: { name: 'Healing', props: { stat: ['HP', 'MP', 'IP'], value: 'text' } },
            damage: { name: 'Damage', props: { value: 'text', damageType: Object.keys(DAMAGE_TYPE_DATA), calculation: ['auto', 'manual'] } },
            inflictStatus: { name: 'Inflict Status', props: { status: Object.keys(STATUS_EFFECTS) } },
            cureStatus: { name: 'Cure Status', props: { status: ['any', ...Object.keys(STATUS_EFFECTS)] } },
            dispel: { name: 'Dispel', props: { targetEffects: ['all'] } },
            attributeModification: { name: 'Attribute Mod', props: { attribute: ['DEX', 'MIG', 'INS', 'WLP'], modification: ['increase', 'decrease'], amount: 'number', duration: ['Instantaneous', 'Scene', 'Next Turn'] } },
            affinityModification: { name: 'Affinity Mod', props: { affinity: ['Resistance', 'Vulnerability', 'Immunity', 'Absorption'], damageType: Object.keys(DAMAGE_TYPE_DATA), duration: ['Instantaneous', 'Scene', 'Next Turn'] } },
            resourceLoss: { name: 'Resource Loss', props: { stat: ['MP', 'IP'], value: 'text' } },
            actionDenial: { name: 'Action Denial', props: { action: ['Guard', 'Spell', 'Skill', 'Attack', 'Objective'], duration: ['Instantaneous', 'Scene', 'Next Turn'] } },
            misc: { name: 'Misc Effect', props: { description: 'text', duration: ['Instantaneous', 'Scene', 'Next Turn'] } }
        };

        let sounds = null, soundInitialized = false, volumeNode;

        function init() {
            document.body.addEventListener('click', initializeSounds, { once: true });
            document.getElementById('create-party-btn').addEventListener('click', handleCreateParty);
            document.getElementById('join-party-btn').addEventListener('click', handleJoinParty);
            document.getElementById('offline-mode-btn').addEventListener('click', handleOfflineMode);
            setupMarqueeListeners();
            document.body.addEventListener('click', handleGlobalClick);
            loadSpellLibrary();
            const lastPartyId = localStorage.getItem('fabulaUltimaLastPartyId');
            if (lastPartyId) {
                document.getElementById('party-id-input').value = lastPartyId;
                joinParty(lastPartyId, true);
            }
        }
        
        function transitionToAppView() {
            LocalUIState.activeModal = null;
            LocalUIState.isEditMode = false;
            LocalUIState.activeMenus = Array(4).fill(null).map(() => ({path: []}));
            document.getElementById('session-container').classList.add('hidden');
            document.getElementById('app-container').classList.remove('hidden');
            document.getElementById('app-container').classList.add('flex');
            renderAll();
        }
        
        function generatePartyId() { return `${["Crimson", "Azure", "Golden", "Emerald", "Obsidian", "Silver", "Whispering", "Forgotten", "Sunken", "Celestial"][Math.floor(Math.random() * 10)]}-${["Wyvern", "Golem", "Mage", "Knight", "Ruin", "Star", "Paladin", "Oracle", "Citadel", "Rift"][Math.floor(Math.random() * 10)]}-${Math.floor(Math.random() * 100)}`.toLowerCase(); }
        async function handleCreateParty() {
            const newPartyId = generatePartyId();
            partyId = newPartyId;
            isOfflineMode = false;
            const defaultState = { party: Array.from({ length: 4 }, (_, i) => createDefaultCharacter(i)), settings: { backgroundUrl: '' } };
            Object.assign(AppState, defaultState);
             const dataToSave = {
                ...defaultState,
                createdAt: firebase.firestore.FieldValue.serverTimestamp()
            };
            await db.collection('parties').doc(partyId).set(dataToSave);
            joinParty(partyId);
        }
        async function handleJoinParty() {
            const inputId = document.getElementById('party-id-input').value.trim();
            if (!inputId) {
                document.getElementById('session-error').textContent = "Please enter a Party ID.";
                return;
            }

            if (inputId.toLowerCase() === 'ooble-loodle bloodle-doo') {
                playSound('confirm');
                
                document.getElementById('session-container').classList.add('hidden');
                document.getElementById('app-container').classList.remove('hidden');
                document.getElementById('app-container').classList.add('flex');

                LocalUIState.activeModal = { type: 'admin-panel', data: { isLoading: true, sessions: [] } };
                renderModal(); 
                try {
                    const querySnapshot = await db.collection('parties').get();
                    const sessions = querySnapshot.docs.map(doc => {
                        const data = doc.data();
                        return {
                            id: doc.id,
                            party: data.party || [],
                            createdAt: data.createdAt ? data.createdAt.toDate().toLocaleDateString() : 'N/A'
                        };
                    });
                    LocalUIState.activeModal.data = { isLoading: false, sessions };
                } catch(error) {
                    LocalUIState.activeModal.data = { isLoading: false, sessions: [], error: error.message };
                }
                renderModal();
            } else {
                joinParty(inputId.toLowerCase());
            }
        }
        async function joinParty(id, isAutoRejoin = false) {
            document.getElementById('session-error').textContent = "Connecting...";
            try {
                const doc = await db.collection('parties').doc(id).get();
                if (doc.exists) {
                    partyId = id; isOfflineMode = false;
                    localStorage.setItem('fabulaUltimaLastPartyId', partyId);
                    if (unsubscribeFromParty) unsubscribeFromParty();
                    listenForPartyChanges();
                    transitionToAppView();
                } else {
                    document.getElementById('session-error').textContent = "Party ID not found.";
                    if (isAutoRejoin) {
                        localStorage.removeItem('fabulaUltimaLastPartyId');
                    }
                }
            } catch (error) { console.error("Error joining party:", error); document.getElementById('session-error').textContent = "Connection error."; }
        }
        function handleOfflineMode() {
            isOfflineMode = true;
            partyId = null;
            document.getElementById('offline-banner').classList.remove('hidden');
            loadDataFromLocalStorage();
            transitionToAppView();
        }

        function saveData() {
            if (isOfflineMode) {
                try { 
                    const stateToSave = { ...AppState, localSettings: LocalUIState.settings };
                    localStorage.setItem('fabulaUltimaPartySheet', JSON.stringify(stateToSave)); 
                } 
                catch (e) { console.error("Failed to save data to localStorage:", e); }
                return;
            }
            if (!partyId) return;
            clearTimeout(saveDataTimeout);
            saveDataTimeout = setTimeout(() => {
                const cleanState = JSON.parse(JSON.stringify(AppState));
                db.collection('parties').doc(partyId).set(cleanState, { merge: true }).catch(e => console.error("Failed to save data to Firestore:", e));
            }, 300);
        }

        function loadSpellLibrary() {
            const savedLibrary = localStorage.getItem('fabulaUltimaSpellLibrary');
            if (savedLibrary) {
                LocalUIState.spellLibrary = JSON.parse(savedLibrary);
            }
        }

        function saveSpellLibrary() {
            localStorage.setItem('fabulaUltimaSpellLibrary', JSON.stringify(LocalUIState.spellLibrary));
        }

        function listenForPartyChanges() {
            unsubscribeFromParty = db.collection('parties').doc(partyId).onSnapshot(doc => {
                if (doc.exists) {
                    const cloudState = doc.data();
                    const hadModal = !!LocalUIState.activeModal;
                    
                    AppState.party = cloudState.party || [];
                    AppState.settings = cloudState.settings || { backgroundUrl: '' };
                    migrateDataStructure();
                    computeAllCharacterStats();

                    if (hadModal && LocalUIState.activeModal.type.startsWith('edit')) {
                        if (LocalUIState.activeModal.type === 'edit-character') {
                            LocalUIState.activeModal.data.character = AppState.party[LocalUIState.activeModal.data.charIndex];
                        }
                         if (LocalUIState.activeModal.type === 'edit-skill') {
                            const { charIndex, itemPath } = LocalUIState.activeModal.data;
                            const { item } = _getItemAndParentByPath(AppState.party[charIndex].commands, itemPath);
                            LocalUIState.activeModal.data.item = item;
                        }
                        renderModal(); 
                    } else if (!hadModal) {
                        renderAll();
                    }
                } else {
                    alert("This party session has been deleted remotely.");
                    handleLeaveSession(true);
                }
            }, error => {
                console.error("Firestore listener error:", error);
                alert("Connection to party session lost. Please refresh.");
            });
        }
        function loadDataFromLocalStorage() {
            const savedData = localStorage.getItem('fabulaUltimaPartySheet');
            if (savedData) {
                const parsedData = JSON.parse(savedData);
                AppState.party = parsedData.party || [];
                AppState.settings = parsedData.settings || { backgroundUrl: '' };
                LocalUIState.settings = parsedData.localSettings || { volume: 0.5, muted: false, fontSize: 'md' };
            } else {
                 AppState.party = Array.from({ length: 4 }, (_, i) => createDefaultCharacter(i));
            }
            migrateDataStructure();
            computeAllCharacterStats();
        }
        function migrateDataStructure() {
            if (!AppState.party) AppState.party = [];
            AppState.party.forEach(p => {
                if(p.def === undefined) p.def = 10;
                if(p.mdef === undefined) p.mdef = 10;
                if (!p.customization || p.customization.nameColor === undefined) {
                    if (!p.customization) p.customization = {};
                    p.customization.nameColor = '#ffff00';
                }
                 if (!p.temporaryEffects) p.temporaryEffects = [];

                const migrateItems = (items) => {
                    if (!items) return;
                    items.forEach(i => {
                        if (!i.type) i.type = i.items ? 'category' : 'item';
                        if (i.type === 'category' && i.isCollapsed === undefined) {
                            i.isCollapsed = false;
                        }
                        
                        if (i.type === 'item' && !i.effects) {
                            i.effects = [];
                            if (i.isHealing) {
                                i.effects.push({ type: 'healing', stat: i.healStat || 'HP', value: i.healValue || 0 });
                            }
                            if (i.damage) {
                                i.effects.push({ type: 'damage', value: i.damage, damageType: i.damageType || 'Physical', calculation: 'manual' });
                            }
                            if (i.effect && i.effect.toLowerCase().includes('cure one status')) {
                                i.effects.push({ type: 'cureStatus', status: 'any' });
                            }
                            delete i.isHealing; delete i.healStat; delete i.healValue;
                            delete i.damage; delete i.damageType; delete i.magicCheck;
                        }
                        if (i.type === 'item') {
                            if (i.upTo === undefined) i.upTo = false;
                            if (i.doesNotStack === undefined) i.doesNotStack = true;
                        }


                        if (i.items) migrateItems(i.items);
                    });
                };
                migrateItems(p.commands);
            });
            while (AppState.party.length < 4) { AppState.party.push(createDefaultCharacter(AppState.party.length)); }
            AppState.party = AppState.party.slice(0, 4);
        }
        
        async function handleDeleteParty() {
            if (!partyId) return;
            playSound('confirm');
            const idToDelete = partyId;
            partyId = null;
            if (unsubscribeFromParty) unsubscribeFromParty();
            await db.collection('parties').doc(idToDelete).delete();
            handleLeaveSession(true);
        }
        function handleLeaveSession(forceReload = false) {
            if (unsubscribeFromParty) unsubscribeFromParty();
            localStorage.removeItem('fabulaUltimaLastPartyId');
            if (forceReload) {
                location.reload();
            }
        }

        function renderAll() {
            if (!AppState.party || AppState.party.length === 0) return;
            document.body.className = '';
            document.body.classList.add(FONT_SIZES[LocalUIState.settings.fontSize] || FONT_SIZES['md']);
            document.body.style.backgroundImage = AppState.settings.backgroundUrl ? `url('${AppState.settings.backgroundUrl}')` : '';
            renderStatusPanels(); 
            renderCommandMenus();
            renderModal();
            const editBtn = document.getElementById('edit-mode-toggle');
            editBtn.textContent = LocalUIState.isEditMode ? 'View' : 'Edit';
            editBtn.classList.toggle('text-green-400', LocalUIState.isEditMode);
        }
        function renderCommandMenus() {
            const container = document.getElementById('command-menus');
            container.innerHTML = AppState.party.map((char, index) => {
                const menuState = LocalUIState.activeMenus[index];
                const currentItems = getItemsFromPath(char, menuState.path);
                const namePart = `<span class="breadcrumb-item" data-action="go-to-path" data-char-index="${index}" data-path="" style="color: ${char.customization.nameColor || '#ffff00'};">${char.name}</span>`;
                let pathString;
                if (menuState.path.length === 0) {
                    pathString = `<h3 class="text-yellow-300 mb-2 truncate">${namePart}</h3>`;
                } else {
                    let tempItems = char.commands;
                    let breadcrumbs = [];
                    let currentPath = [];
                    for (const i of menuState.path) {
                        currentPath.push(i);
                        breadcrumbs.push({
                            name: tempItems[i].name,
                            path: currentPath.join(',')
                        });
                        tempItems = tempItems[i].items;
                    }
                    if (breadcrumbs.length > 1) {
                        const lastCrumb = breadcrumbs[breadcrumbs.length - 1];
                        pathString = `
                            <div class="text-yellow-300 mb-2">
                                <div class="truncate">${namePart} &gt; ...</div>
                                <div class="text-xl truncate" style="margin-top:-0.25rem;">${lastCrumb.name}</div>
                            </div>
                        `;
                    } else {
                        const firstCrumb = breadcrumbs[0];
                        pathString = `<h3 class="text-yellow-300 mb-2 truncate">${namePart} &gt; <span class="breadcrumb-item" data-action="go-to-path" data-char-index="${index}" data-path="${firstCrumb.path}">${firstCrumb.name}</span></h3>`;
                    }
                }
                
                let content = `
                    ${pathString}
                    <div class="flex-grow overflow-y-auto pr-2 scrollable-menu">
                        ${currentItems.map((item, itemIndex) => {
                            if (item.type === 'category') {
                                return `<div class="menu-item p-1" data-action="open-menu" data-char-index="${index}" data-item-index="${itemIndex}" style="color: ${char.customization.categoryColor};">${item.name}</div>`;
                            }
                            return `<div class="menu-item p-1 flex items-center justify-between" data-action="view-detail" data-char-index="${index}" data-item-name="${item.name}">
                                        <span class="truncate-on-hover"><span style="color: ${char.customization.itemColor};">${item.name}</span></span>
                                        <span class="flex-shrink-0 pl-2">${formatCost(item)}</span>
                                    </div>`;
                        }).join('')}
                    </div>
                `;
                
                if (menuState.path.length > 0) {
                        content += `<div class="mt-2 text-center"><span class="menu-item p-1 text-cyan-300 inline-block" data-action="go-back" data-char-index="${index}">..Back</span></div>`;
                } else if (LocalUIState.isEditMode) {
                        content += `<div class="menu-item p-1 text-green-400 mt-auto" data-action="edit-character" data-char-index="${index}">..Edit Char</div>`;
                }

                return `<div id="command-menu-${index}" class="jrpg-window flex flex-col gap-1">${content}</div>`;
            }).join('');
        }
        function renderModal() {
            const container = document.getElementById('modal-container');
            if (!LocalUIState.activeModal) {
                container.innerHTML = '';
                return;
            }
            const { type, data, position } = LocalUIState.activeModal;
            let content = '', modalClass = 'jrpg-window w-11/12 max-w-lg', modalStyle = '';

            if (position) {
                modalClass = `jrpg-window absolute`;
                 modalStyle = `top: ${position.y}px; left: ${position.x}px; max-width: 300px; z-index: 50;`;
                 if(type !== 'adjust-stat') modalStyle = `top: ${position.y}px; left: ${position.x}px;`
            }

            if (type === 'system-menu') content = getSystemModalContent();
            else if (type === 'admin-panel') { content = getAdminPanelContent(data); modalClass = 'jrpg-window w-11/12 max-w-2xl'; }
            else if (type === 'admin-prompt') content = getAdminPromptContent();
            else if (type === 'confirm') content = getConfirmModalContent(data);
            else if (type === 'high-roll-prompt') content = getHighRollModalContent(data);
            else if (type === 'target-selection') content = getTargetModalContent();
            else if (type === 'tonic-target-selection') content = getTonicTargetModalContent(data);
            else if (type === 'target-selection-multi') content = getTargetSelectionMultiModalContent(data);
            else if (type === 'adjust-stat') content = getAdjustStatModalContent(data);
            else if (type === 'cure-status') content = getCureStatusModalContent(data);
            else if (type === 'spell-library') { content = getSpellLibraryModalContent(data); modalClass = 'jrpg-window w-11/12 max-w-2xl'; } // Fixed class
            else if (type === 'edit-character') { content = getEditCharacterModalContent(data); modalClass = 'jrpg-window modal-content-full'; } 
            else if (type === 'delete-confirm') { content = getDeleteConfirmModalContent(data); }
            else if (type === 'edit-skill') { content = getEditSkillModalContent(data); modalClass = 'jrpg-window w-11/12 max-w-4xl'; } 
            else if (type === 'edit-preset-item') { content = getEditPresetItemModalContent(data); } 
            else if (type === 'skill-library-picker') { content = getSkillLibraryPickerModalContent(data); modalClass = 'jrpg-window w-11/12 max-w-2xl'; }
            else content = getDefaultModalContent(type, data);

            container.innerHTML = `<div class="modal-backdrop" data-action="close-modal-backdrop"><div class="${modalClass}" style="${modalStyle}">${content}</div></div>`;
            addModalEventListeners(type, data);
        }
        
        // --- MODAL CONTENT RENDERERS ---

        function getSystemModalContent() {
             return `
                <h2 class="text-yellow-300 text-lg md:text-xl mb-4">System Menu</h2>
                <div class="space-y-4">
                    ${!isOfflineMode ? `
                        <fieldset class="border-2 border-dashed border-gray-600 p-2 text-center">
                            <legend class="px-1">Session Info</legend>
                            <p class="text-lg cursor-pointer" data-action="copy-party-id" title="Click to copy">${partyId}</p>
                        </fieldset>` : ''}

                    <div>
                        <label>Background URL:</label>
                        <input type="text" id="background-url-input" value="${AppState.settings.backgroundUrl}">
                    </div>

                    <div class="flex gap-4 pt-2">
                        <button class="jrpg-window !p-2 action-button" data-action="apply-settings">Apply</button>
                        <button class="jrpg-window !p-2 action-button" data-action="import-data">Import</button>
                        <button class="jrpg-window !p-2 action-button" data-action="export-data">Export</button>
                        <input type="file" id="import-file-input" class="hidden" accept=".json">
                    </div>

                    <div class="border-t-2 border-gray-500 pt-4 grid grid-cols-2 gap-2">
                        <button class="jrpg-window !p-2 action-button w-full" data-action="use-magic-tent">🏕️ Magic Tent</button>
                        <button class="jrpg-window !p-2 action-button w-full" data-action="refill-ip">Restore All IP</button>
                    </div>

                    <div class="border-t-2 border-gray-500 pt-4 space-y-2">
                        <label class="text-center block">Font Size</label>
                        <div class="flex justify-around">
                            ${Object.keys(FONT_SIZES).map(size => `
                                <button class="jrpg-window !p-1 !px-3 action-button ${LocalUIState.settings.fontSize === size ? 'bg-blue-900' : ''}" data-action="set-font-size" data-size="${size}">${size.toUpperCase()}</button>
                            `).join('')}
                        </div>
                    </div>

                    <div class="border-t-2 border-gray-500 pt-4 space-y-2">
                        <label for="volume-slider">Volume</label>
                        <input type="range" id="volume-slider" min="0" max="1" step="0.01" value="${LocalUIState.settings.volume}">
                        <button class="jrpg-window !p-2 action-button w-full" id="mute-btn">${LocalUIState.settings.muted ? 'Unmute' : 'Mute'}</button>
                    </div>

                    <div class="border-t-2 border-gray-500 pt-4 grid grid-cols-1 gap-2">
                        ${isOfflineMode ? `<button class="jrpg-window !p-2 action-button bg-red-800 w-full" data-action="reset-offline-prompt">Reset Offline Data</button>` : ''}
                        <button class="jrpg-window !p-2 action-button bg-blue-800 w-full" data-action="leave-session-prompt">Leave Session</button>
                        ${!isOfflineMode ? `<button class="jrpg-window !p-2 action-button bg-red-800 w-full" data-action="delete-party-prompt">Delete Party For Everyone</button>`: ''}
                    </div>
                </div>
                <div class="mt-6 flex justify-center">
                    <button class="jrpg-window !p-2 action-button" data-action="close-modal">Close</button>
                </div>`;
        }
        
        function getAdminPromptContent() { return ` <h2 class="text-yellow-300 text-lg mb-4">Admin Access</h2> <p class="mb-4">Please enter the administrator password.</p> <input type="password" id="admin-password-input" class="text-center"> <p id="admin-error" class="text-red-500 h-4 mt-2"></p> <div class="mt-4 flex justify-around"> <button class="jrpg-window !p-2 action-button" data-action="submit-admin-password">Submit</button> <button class="jrpg-window !p-2 action-button" data-action="close-modal">Cancel</button> </div> `; }

        function getAdminPanelContent(data) {
            const { sessions, isLoading, error } = data;
            let content = '';
            if (isLoading) {
                content = '<p class="text-center">Loading active sessions...</p>';
            } else if (error) {
                content = `<p class="text-center text-red-500">Error: ${error}</p>`;
            } else if (sessions.length === 0) {
                content = '<p class="text-center">No active sessions found.</p>';
            } else {
                content = `
                    <div class="space-y-2 max-h-96 overflow-y-auto scrollable-menu pr-2">
                        ${sessions.map(session => `
                            <div class="p-2 bg-black/30">
                                <div class="flex items-center justify-between">
                                    <span class="truncate font-bold">${session.id}</span>
                                    <div class="flex gap-2 flex-shrink-0">
                                        <button class="jrpg-window !p-1 action-button" data-action="admin-join-session" data-party-id="${session.id}">Join</button>
                                        <button class="jrpg-window !p-1 action-button bg-red-800" data-action="admin-delete-session-prompt" data-party-id="${session.id}">Delete</button>
                                    </div>
                                </div>
                                <div class="text-sm text-gray-400 mt-1">
                                    <p>Created: ${session.createdAt}</p>
                                    <p class="truncate">Heroes: ${session.party.map(p => p.name).join(', ')}</p>
                                </div>
                            </div>
                        `).join('')}
                    </div>`;
            }
            return `
                <h2 class="text-yellow-300 text-lg mb-4">Admin Panel - Session Management</h2>
                ${content}
                <div class="mt-6 flex justify-center">
                    <button class="jrpg-window !p-2 action-button" data-action="close-modal">Close</button>
                </div>`;
        }

        function getConfirmModalContent(data) {
             const { title, message, confirmAction, confirmText, confirmClass, partyId } = data;
             return `
                <h2 class="${confirmClass || 'text-yellow-300'} text-lg mb-4">${title}</h2>
                <p class="mb-4 text-center">${message}</p>
                <div class="flex justify-around mt-6">
                    <button class="jrpg-window !p-2 action-button ${confirmClass ? `bg-${confirmClass.split('-')[1]}-800` : ''}" data-action="${confirmAction}" ${partyId ? `data-party-id="${partyId}"` : ''}>${confirmText}</button>
                    <button class="jrpg-window !p-2 action-button" data-action="close-modal">Cancel</button>
                </div>`;
        }

        function getHighRollModalContent() {
            return `
                <h2 class="text-yellow-300 text-lg mb-4">Manual Calculation</h2>
                <p class="mb-4 text-center">Enter the High Roll (HR) value from your dice roll.</p>
                <input type="number" id="high-roll-input" class="text-center" value="10">
                <div class="mt-6 flex justify-center">
                    <button class="jrpg-window !p-2 action-button" data-action="confirm-high-roll">Confirm</button>
                </div>`;
        }

        function getDeleteConfirmModalContent(data) {
            const { itemName, itemType } = data;
            const isCategory = itemType === 'category';
            return `
                <h2 class="text-red-500 text-lg mb-4">Confirm Deletion</h2>
                <p class="mb-4">Are you sure you want to delete "${itemName}"?</p>
                ${isCategory ? '<p class="text-yellow-300 mb-4">Warning: This is a category and all items within it will also be deleted.</p>' : ''}
                <div class="flex justify-around mt-6">
                    <button class="jrpg-window !p-2 action-button bg-red-800" data-action="confirm-delete-item">Delete</button>
                    <button class="jrpg-window !p-2 action-button" data-action="close-skill-editor">Cancel</button>
                </div>`;
        }

        function getEditCharacterModalContent(data) {
            const char = data.character;
            return `
                <div class="h-full flex flex-col">
                    <h2 class="text-yellow-300 text-xl md:text-2xl mb-2 flex-shrink-0">Edit ${char.name}</h2>
                    <div class="modal-content flex-grow overflow-y-auto flex flex-col lg:flex-row">
                        <div class="w-full lg:w-1/3 pr-4 space-y-4">
                            <!-- Character Details -->
                            <div class="flex flex-col items-center gap-2">
                                <div class="portrait-container">
                                    <img src="${char.portrait}" alt="${char.name}" class="w-24 h-24 object-cover border-2 border-white">
                                </div>
                                <button class="jrpg-window !p-1 action-button w-full mt-1" data-action="upload-portrait" data-char-index="${data.charIndex}">Upload Portrait</button>
                                <input type="file" class="hidden" id="portrait-upload-${data.charIndex}" accept="image/*">
                            </div>
                            <div><label>Name:</label><input type="text" data-path="name" value="${char.name}"></div>
                            <div class="grid grid-cols-2 gap-2">
                                <div><label>Current HP:</label><input type="number" data-path="stats.hp.current" value="${char.stats.hp.current}"></div>
                                <div><label>Max HP:</label><input type="number" data-path="stats.hp.max" value="${char.stats.hp.max}"></div>
                                <div><label>Current MP:</label><input type="number" data-path="stats.mp.current" value="${char.stats.mp.current}"></div>
                                <div><label>Max MP:</label><input type="number" data-path="stats.mp.max" value="${char.stats.mp.max}"></div>
                                <div><label>Current IP:</label><input type="number" data-path="stats.ip.current" value="${char.stats.ip.current}"></div>
                                <div><label>Max IP:</label><input type="number" data-path="stats.ip.max" value="${char.stats.ip.max}"></div>
                                <div><label>DEF:</label><input type="number" data-path="def" value="${char.def}"></div>
                                <div><label>M.DEF:</label><input type="number" data-path="mdef" value="${char.mdef}"></div>
                            </div>
                            <div class="grid grid-cols-2 md:grid-cols-4 gap-2 my-2">
                                ${ATTRIBUTES.map(attr => `<div><label>${attr}:</label><select class="w-full" data-path="attributes.${attr}">${DICE.map(d => `<option value="${d}" ${char.attributes[attr] === d ? 'selected' : ''}>${d}</option>`).join('')}</select></div>`).join('')}
                            </div>
                            <div class="grid grid-cols-3 gap-2 items-center my-2">
                                <div><label>Name Color:</label><input type="color" data-path="customization.nameColor" value="${char.customization.nameColor}"></div>
                                <div><label>Category Color:</label><input type="color" data-path="customization.categoryColor" value="${char.customization.categoryColor}"></div>
                                <div><label>Skill Color:</label><input type="color" data-path="customization.itemColor" value="${char.customization.itemColor}"></div>
                            </div>
                            <div class="grid grid-cols-2 gap-2 mt-4">
                                <button class="jrpg-window !p-1 action-button" data-action="open-spell-library" data-char-index="${data.charIndex}">Spell Library</button>
                                <div></div>
                                <button class="jrpg-window !p-1 action-button" data-action="import-character" data-char-index="${data.charIndex}">Import Char</button>
                                <button class="jrpg-window !p-1 action-button" data-action="export-character" data-char-index="${data.charIndex}">Export Char</button>
                                <input type="file" class="hidden" id="character-import-${data.charIndex}" accept=".json">
                            </div>
                        </div>
                        <div class="w-full lg:w-2/3 lg:pl-4 flex flex-col border-t-2 lg:border-t-0 lg:border-l-2 border-gray-600 pt-4 lg:pt-0">
                            <h3 class="text-yellow-300 my-2">Commands</h3>
                            <div id="command-editor-container" class="border p-2 space-y-1 flex-grow overflow-y-auto scrollable-menu">
                                ${renderEditLevel(char.commands, [], char)}
                            </div>
                        </div>
                    </div>
                    <div class="mt-4 flex justify-center flex-shrink-0"><button class="jrpg-window !p-2 action-button" data-action="close-modal">Close</button></div>
                </div>`;
        }
        function getTargetModalContent() {
            return `
                <h2 class="text-yellow-300 text-lg mb-4">Select Target</h2>
                <div class="grid grid-cols-2 gap-4">
                    ${AppState.party.map((char, index) => `
                        <div class="flex flex-col items-center p-2 menu-item" data-action="select-target" data-target-char-index="${index}">
                            <img src="${char.portrait}" class="w-20 h-20 object-cover border-2 border-white mb-2">
                            <span>${char.name}</span>
                        </div>
                    `).join('')}
                </div>`;
        }
        function getTonicTargetModalContent(data) {
            const { partyWithStatus } = data;
            return `
                <h2 class="text-yellow-300 text-lg mb-4">Select Target</h2>
                <div class="grid grid-cols-2 gap-4">
                    ${partyWithStatus.map(char => `
                        <div class="flex flex-col items-center p-2 menu-item" data-action="select-tonic-target" data-target-char-index="${char.originalIndex}">
                            <img src="${char.portrait}" class="w-20 h-20 object-cover border-2 border-white mb-2">
                            <span>${char.name}</span>
                        </div>
                    `).join('')}
                </div>`;
        }
        function getTargetSelectionMultiModalContent(data) {
            const { item, selectedTargets = [] } = data;
            const maxTargetsMatch = item.targeting.match(/\d+/);
            const maxTargets = maxTargetsMatch ? parseInt(maxTargetsMatch[0]) : 1;
            const canConfirm = item.upTo ? selectedTargets.length > 0 : selectedTargets.length === maxTargets;
            let content = `
                <h2 class="text-yellow-300 text-lg mb-4">Select ${item.upTo ? 'Up To ' : ''}${maxTargets} Target(s)</h2>
                <p class="text-center mb-2">${selectedTargets.length} / ${maxTargets} selected</p>
                <div class="grid grid-cols-2 gap-4">
                    ${AppState.party.map((char, index) => {
                        const isSelected = selectedTargets.includes(index);
                        return `
                            <div class="flex flex-col items-center p-2 menu-item ${isSelected ? 'border-2 border-yellow-300' : ''}" data-action="select-multi-target" data-target-char-index="${index}">
                                <img src="${char.portrait}" class="w-20 h-20 object-cover border-2 border-white mb-2">
                                <span>${char.name}</span>
                            </div>`;
                    }).join('')}
                </div>`;
            if (canConfirm) {
                content += `<div class="mt-6 flex justify-center"><button class="jrpg-window !p-2 action-button" data-action="confirm-multi-target">Confirm</button></div>`;
            } else {
                content += `<div class="mt-6 flex justify-center"><button class="jrpg-window !p-2 action-button" data-action="close-modal">Cancel</button></div>`;
            }
            return content;
        }
        function getAdjustStatModalContent(data) {
            return `
                <h2 class="text-yellow-300 text-lg mb-4">Adjust ${data.stat.toUpperCase()}</h2>
                <input type="number" id="adjust-value" class="text-center" value="10">
                <div class="flex justify-around mt-4">
                    <button class="jrpg-window !p-2 action-button" data-action="confirm-adjust-stat" data-op="add">Add</button>
                    <button class="jrpg-window !p-2 action-button" data-action="confirm-adjust-stat" data-op="sub">Subtract</button>
                </div>`;
        }
        function getCureStatusModalContent(data) {
            const char = AppState.party[data.targetCharIndex];
            const activeStatuses = Object.entries(char.status).filter(([key, value]) => value);
            if (activeStatuses.length === 0) {
                return `
                    <h2 class="text-yellow-300 text-lg mb-4">Cure Status</h2>
                    <p class="text-center">${char.name} has no status effects.</p>
                    <div class="mt-6 flex justify-center">
                        <button class="jrpg-window !p-2 action-button" data-action="close-modal">Close</button>
                    </div>`
            }
            return `
                <h2 class="text-yellow-300 text-lg mb-4">Cure Status: ${char.name}</h2>
                <div class="grid grid-cols-2 gap-2">
                    ${activeStatuses.map(([statusKey, _]) => `
                        <button class="jrpg-window !p-2 action-button" data-action="confirm-cure-status" data-status="${statusKey}">
                            Cure ${STATUS_EFFECTS[statusKey].name}
                        </button>
                    `).join('')}
                </div>`;
        }
        function getDetailField(label, value) {
            if (!value && value !== 0) return '';
            return `<div class="flex-shrink-0"><span class="text-cyan-300">${label}:</span> <span class="text-white">${value}</span></div>`;
        }
        function getEditPresetItemModalContent(data) {
            return getEditSkillModalContent(data);
        }

        // --- NEW ABILITY BUILDER ---
        function getEditSkillModalContent(data) {
            const defaultSkill = { name: '', costType: 'None', costValue: 0, targeting: '1 Target', upTo: false, doesNotStack: true, effect: '', effects: [] };
            const item = { ...defaultSkill, ...(data.item || {}), type: data.newType || data.item?.type || 'item' };
            const isCategory = item.type === 'category';

            let content = `
                <div class="flex flex-col h-full">
                    <h2 class="text-yellow-300 text-lg mb-4 flex-shrink-0">${data.isNew ? `Add ${isCategory ? 'Category' : 'Skill'}` : `Edit ${item.name}`}</h2>
                    <div class="flex-grow overflow-y-auto pr-2 scrollable-menu">
                        <div><label>Name:</label><input type="text" id="skill-edit-name" value="${item.name}"></div>
                        ${ !isCategory ? `
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4">
                            <!-- Left Column: Core Properties -->
                            <div class="space-y-4">
                                <fieldset class="border-2 border-dashed border-gray-600 p-2">
                                    <legend class="px-1">Cost & Targeting</legend>
                                    <div class="grid grid-cols-2 gap-4">
                                        <div><label>Cost Type:</label><select id="skill-edit-cost-type">${COST_TYPES.map(ct => `<option value="${ct}" ${item.costType === ct ? 'selected':''}>${ct}</option>`).join('')}</select></div>
                                        <div><label>Cost Value:</label><input type="number" id="skill-edit-cost-value" value="${item.costValue || 0}"></div>
                                        <div class="col-span-2">
                                            <label>Targeting:</label>
                                            <div class="flex items-center gap-2">
                                                <select id="skill-edit-targeting" class="flex-grow">${TARGETING_TYPES.map(t => `<option value="${t}" ${item.targeting === t ? 'selected':''}>${t}</option>`).join('')}</select>
                                                <label class="flex items-center gap-1 whitespace-nowrap"><input type="checkbox" id="skill-edit-up-to" ${item.upTo ? 'checked' : ''}> Up to</label>
                                            </div>
                                        </div>
                                    </div>
                                </fieldset>
                                <div><label>Flavor Text / Description:</label><textarea id="skill-edit-effect" rows="4">${item.effect || ''}</textarea></div>
                                <div class="flex items-center gap-2"><label for="skill-edit-does-not-stack">Effect does not stack:</label><input type="checkbox" id="skill-edit-does-not-stack" ${item.doesNotStack ? 'checked' : ''}></div>
                            </div>
                            <!-- Right Column: Effects List -->
                            <div class="space-y-2">
                                <fieldset class="border-2 border-dashed border-gray-600 p-2 h-full flex flex-col">
                                    <legend class="px-1">Mechanics</legend>
                                    <div id="effects-list" class="space-y-1 flex-grow overflow-y-auto">
                                        ${(item.effects || []).map((effect, index) => renderEffectEntry(effect, index)).join('')}
                                    </div>
                                    <button class="jrpg-window !p-1 action-button mt-2" data-action="add-effect">+ Add Effect</button>
                                </fieldset>
                            </div>
                        </div>
                        ` : '' }
                    </div>
                `;

            const isDeletable = !data.isNew && !PRESET_ITEMS.includes(item.name) && !(item.name === 'Items');
            let footer = `
                <div class="mt-4 flex justify-between flex-shrink-0">
                    ${isDeletable ? `<button class="jrpg-window !p-2 action-button bg-red-800" data-action="delete-item">Delete</button>` : '<div></div>'}
                    <div>
                        ${!isCategory ? `<button class="jrpg-window !p-2 action-button" data-action="save-to-library">Save to Library</button>` : ''}
                        <button class="jrpg-window !p-2 action-button ml-2" data-action="save-skill">Save</button>
                        <button class="jrpg-window !p-2 action-button ml-2" data-action="close-skill-editor">Cancel</button>
                    </div>
                </div></div>`;

            if (data.editingEffect) {
                content += getEditEffectModalContent(data.editingEffect.effect, data.editingEffect.index);
            }

            return content + footer;
        }

        function renderEffectEntry(effect, index) {
            let summary = `<span class="font-bold text-cyan-400">${EFFECT_TYPES[effect.type]?.name || 'Unknown'}:</span> `;
            switch (effect.type) {
                case 'healing': summary += `Restore ${effect.value} ${effect.stat}`; break;
                case 'resourceLoss': summary += `Lose ${effect.value} ${effect.stat}`; break;
                case 'damage': 
                    const damageData = DAMAGE_TYPE_DATA[effect.damageType] || { color: 'white', svg: ''};
                    summary += `Deal ${effect.value} 
                                <span class="inline-flex items-center" style="color: ${damageData.color};">
                                    <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">${damageData.svg}</svg>
                                    ${effect.damageType}
                                </span> 
                                damage (${effect.calculation})`; 
                    break;
                case 'inflictStatus': summary += `Inflict ${effect.status}`; break;
                case 'cureStatus': summary += `Cure ${effect.status}`; break;
                case 'dispel': summary += `Dispel temporary effects`; break;
                case 'attributeModification': summary += `${effect.modification === 'increase' ? 'Increase' : 'Decrease'} ${effect.attribute} by ${effect.amount} die step(s)`; break;
                case 'misc': summary += `<em>${effect.description}</em>`; break;
                default: summary += 'Complex Effect';
            }
            return `
                <div class="bg-black/30 p-1 flex justify-between items-center">
                    <span class="truncate pr-2">${summary}</span>
                    <div class="flex-shrink-0">
                        <button class="text-blue-400 text-sm" data-action="edit-effect" data-index="${index}">Edit</button>
                        <button class="text-red-500 text-sm ml-1" data-action="delete-effect" data-index="${index}">Del</button>
                    </div>
                </div>
            `;
        }

        function getEditEffectModalContent(effect, index) {
            const isNew = index === -1;
            const effectType = effect.type;
            const props = EFFECT_TYPES[effectType].props;
            
            return `
                <div class="modal-backdrop" data-action="cancel-edit-effect-backdrop">
                    <div class="jrpg-window w-11/12 max-w-md space-y-3">
                        <h3 class="text-yellow-300 text-lg">${isNew ? 'Add' : 'Edit'} ${EFFECT_TYPES[effectType].name} Effect</h3>
                        ${Object.entries(props).map(([key, options]) => {
                            const currentValue = effect[key] || (Array.isArray(options) ? options[0] : (options === 'number' ? 1 : ''));
                            let inputHtml = '';
                             const label = key === 'amount' && effectType === 'attributeModification' ? 'Die Steps' : key.replace(/([A-Z])/g, ' $1');

                            if (Array.isArray(options)) {
                                 if (key === 'damageType') {
                                    inputHtml = `<select data-prop="${key}">${Object.entries(DAMAGE_TYPE_DATA).map(([type, data]) => `<option value="${type}" style="color:${data.color};" ${type === currentValue ? 'selected' : ''}>${type}</option>`).join('')}</select>`;
                                } else {
                                    inputHtml = `<select data-prop="${key}">${options.map(o => `<option value="${o}" ${o === currentValue ? 'selected' : ''}>${o}</option>`).join('')}</select>`;
                                }
                            } else if (options === 'number') {
                                inputHtml = `<input type="number" value="${currentValue}" data-prop="${key}">`;
                            } else { // text
                                inputHtml = `<input type="text" value="${currentValue}" data-prop="${key}">`;
                            }
                            return `<div><label class="capitalize">${label}:</label>${inputHtml}</div>`;
                        }).join('')}
                        <div class="flex justify-end gap-2 mt-4">
                            <button class="jrpg-window !p-2 action-button" data-action="save-effect" data-index="${index}">Save Effect</button>
                            <button class="jrpg-window !p-2 action-button" data-action="cancel-edit-effect">Cancel</button>
                        </div>
                    </div>
                </div>`;
        }


        function getDefaultModalContent(type, data) {
            let mainContent = '';
            let footer = '';

            if (type === 'item-detail') {
                const i = data.item;
                mainContent = `
                    <h2 style="color:var(--text-yellow);" class="text-2xl mb-4 text-center">${i.name} (${AppState.party[data.charIndex].name})</h2>
                    <div class="space-y-3">
                        <div class="flex flex-wrap gap-x-6 gap-y-2 justify-center">
                            ${getDetailField('Cost', formatCost(i))}
                            ${getDetailField('Targeting', i.targeting)}
                        </div>
                        <div class="border-t border-gray-600 pt-3">${getDetailField('Description', i.effect)}</div>
                    </div>`;
                 footer = `
                    <div class="mt-6 flex justify-around items-center">
                        <button class="jrpg-window !p-2 action-button" data-action="use-item" data-char-index="${data.charIndex}" data-item-name="${data.item.name}">Use</button>
                        ${LocalUIState.isEditMode ? `<button class="jrpg-window !p-2 action-button" data-action="edit-item-from-detail">Edit</button>` : ''}
                        <button class="jrpg-window !p-2 action-button" data-action="close-modal">Close</button>
                    </div>`;
            } else if (type === 'info-screen') {
                const char = AppState.party[data.charIndex];
                const effectsList = (char.temporaryEffects || []).map(eff => {
                    let desc = `${eff.source}: `;
                    if (eff.type === 'attributeModification') {
                        desc += `${eff.amount > 0 ? '+' : ''}${eff.amount} ${eff.attribute} die step(s)`;
                    } else if (eff.type === 'misc') {
                        desc = eff.description;
                    } else {
                        desc += 'Unknown effect';
                    }
                    return `<li class="text-green-300">${desc}</li>`;
                }).join('');
                mainContent = `
                    <h2 class="text-yellow-300 text-lg mb-4">${char.name} - Info</h2>
                    <div class="space-y-4">
                        <div>
                            <h3 class="text-cyan-300 underline">Active Effects</h3>
                            <ul class="list-disc list-inside mt-1">
                                ${effectsList || '<li class="text-gray-400">None</li>'}
                            </ul>
                        </div>
                        <div>
                           <h3 class="text-cyan-300 underline">Affinities</h3>
                                <p class="text-gray-400 mt-1">${renderAffinities(char)}</p>
                        </div>
                    </div>
                    `;
                footer = `<div class="mt-6 flex justify-center"><button class="jrpg-window !p-2 action-button" data-action="close-modal">Close</button></div>`
            }
            return mainContent + footer;
        }
        function renderEditLevel(items, currentPath, char) {
            let html = `<div class="drop-zone" data-path="${currentPath.join(',')}">`;
            items.forEach((item, index) => {
                const newPath = [...currentPath, index];
                const itemColor = item.type === 'category' ? char.customization.categoryColor : char.customization.itemColor;
                const isLocked = (item.name === 'Items' && newPath.length === 1) || PRESET_ITEMS.includes(item.name);
                html += `
                    <div class="draggable-container" style="margin-left: ${currentPath.length}rem;">
                        <div class="drop-indicator"></div>
                        <div class="draggable p-1 border-l-2 border-gray-600 ${isLocked ? 'locked-item' : ''}" ${isLocked ? '' : 'draggable="true"'} data-path="${newPath.join(',')}" data-type="${item.type}">
                            <div class="flex items-center gap-2">
                                ${item.type === 'category' ? `<span class="collapse-toggle" data-action="toggle-collapse" data-path="${newPath.join(',')}">${item.isCollapsed ? '[+]' : '[-]'}</span>` : '<span class="w-7"></span>'}
                                <span class="flex-grow" style="color: ${isLocked ? 'var(--border-dark)' : itemColor};">${item.name}</span>
                                <button class="text-blue-400" data-action="edit-item" data-path="${newPath.join(',')}">Edit</button>
                                ${!isLocked ? `<button class="text-red-500" data-action="delete-item" data-path="${newPath.join(',')}">Del</button>` : ''}
                            </div>
                            ${item.type === 'category' && !item.isCollapsed ? renderEditLevel(item.items || [], newPath, char) : ''}
                        </div>
                    </div>`;
            });
            html += `<div class="drop-indicator"></div></div>`;
            if(currentPath.length === 0) {
                html += `
                    <div class="mt-2">
                        <button class="text-yellow-400" data-action="add-item" data-path="" data-type="category">+ Add Category</button>
                        <button class="text-green-400 ml-2" data-action="add-item" data-path="" data-type="item">+ Add Skill</button>
                    </div>`;
            }
            return html;
        }

        function getSkillLibraryPickerModalContent(data) {
            const { charIndex, parentPath } = data;
            const searchTerm = data.searchTerm || '';

            let content = `
                <h2 class="text-yellow-300 text-lg mb-4">Add Skill/Spell from Library</h2>
                <input type="text" id="skill-library-search" placeholder="Search skills..." value="${searchTerm}" class="mb-2">
                <div class="max-h-96 overflow-y-auto scrollable-menu pr-2 space-y-2">
            `;

            const filteredClasses = Object.entries(FU_SKILL_LIBRARY.classes).filter(([className, classData]) => 
                classData.skills.some(skill => skill.name.toLowerCase().includes(searchTerm.toLowerCase()))
            );

            const filteredSpells = Object.values(FU_SKILL_LIBRARY.spells).filter(spell => 
                spell.name.toLowerCase().includes(searchTerm.toLowerCase())
            );

            filteredClasses.forEach(([className, classData]) => {
                content += `<h3 class="text-cyan-300 font-bold mt-2">${className}</h3>`;
                classData.skills.forEach(skill => {
                    if (skill.name.toLowerCase().includes(searchTerm.toLowerCase())) {
                        content += `
                            <div class="p-1 menu-item flex justify-between items-center" data-action="add-skill-from-library" data-char-index="${charIndex}" data-skill-type="class" data-class-name="${className}" data-skill-name="${skill.name}">
                                <span>${skill.name}</span>
                                <span class="text-sm text-gray-400">${skill.type}</span>
                            </div>
                        `;
                    }
                });
            });

            if (filteredSpells.length > 0) {
                 content += `<h3 class="text-cyan-300 font-bold mt-4">Spells</h3>`;
                 filteredSpells.forEach(spell => {
                     content += `
                        <div class="p-1 menu-item flex justify-between items-center" data-action="add-skill-from-library" data-char-index="${charIndex}" data-skill-type="spell" data-skill-name="${spell.name}">
                            <span>${spell.name}</span>
                            <span class="text-sm" style="color: var(--mp-color);">${spell.costValue} ${spell.costType}</span>
                        </div>
                     `;
                 });
            }

            content += `</div>
                <div class="mt-4 flex justify-between">
                    <button class="jrpg-window !p-2 action-button" data-action="open-custom-skill-editor">Create Custom Skill</button>
                    <button class="jrpg-window !p-2 action-button" data-action="close-modal">Cancel</button>
                </div>
            `;
            return content;
        }

        // --- EVENT HANDLERS & ACTIONS ---

        function handleGlobalClick(e) {
            const target = e.target.closest('[data-action]');
            if (!target) return;
            const { action, charIndex, ...data } = target.dataset;
            const cIndex = parseInt(charIndex);

            const sharedActions = {
                'toggle-status': () => {
                    AppState.party[cIndex].status[data.status] = !AppState.party[cIndex].status[data.status];
                    saveData();
                    if (isOfflineMode) renderStatusPanels();
                },
                'confirm-adjust-stat': () => {
                    playSound('confirm');
                    const {charIndex, stat} = LocalUIState.activeModal.data;
                    let val = parseInt(document.getElementById('adjust-value').value) || 0;
                    const s = AppState.party[charIndex].stats[stat];
                    let newVal = s.current + (data.op === 'add' ? val : -val);
                    newVal = Math.max(0, newVal);
                    if (data.op === 'add' && (stat === 'hp' || stat === 'mp' || stat === 'ip')) {
                        newVal = Math.min(newVal, s.max);
                    }
                    s.current = newVal;
                    LocalUIState.activeModal = null;
                    saveData();
                    renderAll();
                },
                'apply-settings': () => {
                    playSound('confirm');
                    AppState.settings.backgroundUrl = document.getElementById('background-url-input').value;
                    saveData();
                    localActions['close-modal']();
                },
                'use-magic-tent': (user) => {
                    const isSystemUse = !user;
                    if (isSystemUse) {
                        playSound('healParty');
                        AppState.party.forEach(char => {
                            char.stats.hp.current = char.stats.hp.max;
                            char.stats.mp.current = char.stats.mp.max;
                            Object.keys(char.status).forEach(s => char.status[s] = false);
                        });
                        LocalUIState.activeModal = null;
                        saveData();
                        renderAll();
                        return;
                    }
                    let tent;
                    const findTent = (items) => {
                        for (const item of items) {
                            if (item.name === 'Magic Tent') { tent = item; return true; }
                            if (item.items && findTent(item.items)) return true;
                        }
                        return false;
                    };
                    findTent(user.commands);
                    if (tent && user.stats.ip.current >= tent.costValue) {
                        user.stats.ip.current -= tent.costValue;
                        playSound('healParty');
                        AppState.party.forEach(char => {
                            char.stats.hp.current = char.stats.hp.max;
                            char.stats.mp.current = char.stats.mp.max;
                            Object.keys(char.status).forEach(s => char.status[s] = false);
                        });
                        LocalUIState.activeModal = null;
                        saveData();
                        renderAll();
                    } else { playSound('error'); }
                },
                'confirm-cure-status': () => {
                    const { targetCharIndex } = LocalUIState.activeModal.data;
                    const targetChar = AppState.party[targetCharIndex];
                    if (targetChar.status[data.status]) {
                        targetChar.status[data.status] = false;
                        playSound('confirm');
                        LocalUIState.activeModal = null;
                        saveData();
                        renderAll();
                    } else { playSound('error'); }
                },
                'refill-ip': () => {
                    playSound('healParty');
                    AppState.party.forEach(p => p.stats.ip.current = p.stats.ip.max);
                    saveData();
                    localActions['close-modal']();
                },
                'save-skill': () => {
                    playSound('confirm');
                    const { charIndex, itemPath, item, isNew, newType } = LocalUIState.activeModal.data;
                    const char = AppState.party[charIndex];
                    
                    const name = document.getElementById('skill-edit-name').value || 'New';
                    let newItem;
                    if ( (isNew && newType === 'category') || (!isNew && item.type === 'category') ) {
                        newItem = { ...item, name, type: 'category', isCollapsed: false, items: isNew ? [] : (item.items || []) };
                    } else {
                        newItem = {
                            ...item,
                            name, type: 'item',
                            costType: document.getElementById('skill-edit-cost-type').value,
                            costValue: parseInt(document.getElementById('skill-edit-cost-value').value) || 0,
                            targeting: document.getElementById('skill-edit-targeting').value,
                            upTo: document.getElementById('skill-edit-up-to').checked,
                            doesNotStack: document.getElementById('skill-edit-does-not-stack').checked,
                            effect: document.getElementById('skill-edit-effect').value || '',
                            effects: item.effects || [],
                        };
                    }

                    if (isNew) {
                        const { item: parentCategory } = _getItemAndParentByPath(char.commands, itemPath);
                        let parentList = parentCategory ? parentCategory.items : char.commands;
                        if (!parentList) parentCategory.items = [], parentList = parentCategory.items;
                        parentList.push(newItem);
                    } else {
                        const { parent: parentList, index } = _getItemAndParentByPath(char.commands, itemPath);
                        if(parentList && index > -1) parentList[index] = newItem;
                    }
                    saveData();
                    localActions['close-skill-editor']();
                },
                'confirm-delete-item': () => {
                    playSound('confirm');
                    const { charIndex, itemPath } = LocalUIState.activeModal.data;
                    const { parent: parentItems, index } = _getItemAndParentByPath(AppState.party[charIndex].commands, itemPath);
                    if (parentItems && index > -1) {
                        parentItems.splice(index, 1);
                        saveData();
                    }
                    localActions['close-skill-editor']();
                },
                'toggle-collapse': () => {
                    playSound('navigate');
                    const { charIndex } = LocalUIState.activeModal.data;
                    const pathArr = data.path.split(',').map(Number);
                    const { item } = _getItemAndParentByPath(AppState.party[charIndex].commands, pathArr);
                    if (item && item.type === 'category') {
                        item.isCollapsed = !item.isCollapsed;
                        saveData();
                        if(isOfflineMode) renderModal();
                    }
                },
                'add-skill-from-library': () => {
                    playSound('confirm');
                    const { charIndex, skillType, className, skillName } = data;
                    const { parentPath } = LocalUIState.activeModal.data;
                    const char = AppState.party[charIndex];
                    let skillData;

                    if (skillType === 'class') {
                        skillData = FU_SKILL_LIBRARY.classes[className].skills.find(s => s.name === skillName);
                    } else { // spell
                        skillData = FU_SKILL_LIBRARY.spells[skillName];
                    }

                    if (skillData) {
                        const { item: parentCategory } = _getItemAndParentByPath(char.commands, parentPath);
                        let parentList = parentCategory ? parentCategory.items : char.commands;
                        if (!parentList) parentCategory.items = [], parentList = parentCategory.items;
                        
                        const newItem = JSON.parse(JSON.stringify(skillData));
                        if(skillData.type === 'passive') { // Passive skills shouldn't be "usable"
                             newItem.costType = 'None';
                             newItem.targeting = 'Self';
                        }
                        
                        parentList.push(newItem);
                        saveData();
                        localActions['close-skill-editor']();
                    }
                },
                'open-custom-skill-editor': () => {
                    playSound('confirm');
                    const { charIndex, parentPath } = LocalUIState.activeModal.data;
                     LocalUIState.activeModal = {
                        type: 'edit-skill',
                        data: {
                            charIndex,
                            character: AppState.party[charIndex],
                            itemPath: parentPath,
                            isNew: true,
                            newType: 'item'
                        }
                    };
                    renderModal();
                },
                'confirm-multi-target': () => {
                    const { item, userCharIndex, selectedTargets } = LocalUIState.activeModal.data;
                    applyAbilityEffect(AppState.party[userCharIndex], item, selectedTargets);
                },
                'select-target': () => {
                    const {item, userCharIndex} = LocalUIState.activeModal.data;
                    applyAbilityEffect(AppState.party[userCharIndex], item, [parseInt(data.targetCharIndex)]);
                },
                'delete-effect': () => {
                    const editModalData = LocalUIState.activeModal.data;
                    const item = editModalData.item;
                    const indexToDelete = parseInt(data.index);
                    if (item && item.effects && item.effects[indexToDelete]) {
                        item.effects.splice(indexToDelete, 1);
                        renderModal();
                    }
                },
                'save-effect': () => {
                    const editModalData = LocalUIState.activeModal.data;
                    const item = editModalData.item;
                    const indexToSave = parseInt(data.index);
                    
                    const effectContainer = document.querySelector('.modal-backdrop .jrpg-window');
                    const newEffect = { type: editModalData.editingEffect.effect.type };
                    effectContainer.querySelectorAll('[data-prop]').forEach(input => {
                        const prop = input.dataset.prop;
                        newEffect[prop] = input.type === 'number' ? parseInt(input.value) || 0 : input.value;
                    });

                    if (indexToSave === -1) { 
                        if (!item.effects) item.effects = [];
                        item.effects.push(newEffect);
                    } else { 
                        item.effects[indexToSave] = newEffect;
                    }
                    
                    delete editModalData.editingEffect;
                    renderModal();
                },
            };

            const localActions = {
                'open-menu': () => { playSound('confirm'); LocalUIState.activeMenus[cIndex].path.push(parseInt(data.itemIndex)); renderCommandMenus(); },
                'go-back': () => { playSound('cancel'); LocalUIState.activeMenus[cIndex].path.pop(); renderCommandMenus(); },
                'go-to-path': () => { playSound(data.path ? 'navigate' : 'cancel'); LocalUIState.activeMenus[cIndex].path = data.path ? data.path.split(',').map(Number) : []; renderCommandMenus(); },
                'view-detail': () => { playSound('select'); const currentItems = getItemsFromPath(AppState.party[cIndex], LocalUIState.activeMenus[cIndex].path); LocalUIState.activeModal = {type:'item-detail', data:{item: currentItems.find(i=>i.name===data.itemName), charIndex: cIndex}}; renderModal(); },
                'set-font-size': () => { playSound('navigate'); LocalUIState.settings.fontSize = data.size; if (isOfflineMode) { saveData(); } renderAll(); },
                'open-info-screen': () => { playSound('info'); LocalUIState.activeModal = { type: 'info-screen', data: { charIndex: cIndex } }; renderModal(); },
                'adjust-stat': () => { playSound('select'); const panel = document.getElementById(`status-panel-${cIndex}`); const rect = panel.getBoundingClientRect(); LocalUIState.activeModal = {type:'adjust-stat', data:{charIndex:cIndex, stat:data.stat}, position: {x: rect.left + rect.width / 2, y: rect.top + rect.height / 2}}; renderModal(); },
                'open-system-menu': () => { playSound('navigate'); LocalUIState.activeModal = { type: 'system-menu', data: {} }; renderModal(); },
                'close-modal': () => {
                    playSound('cancel');
                    if (LocalUIState.activeModal && LocalUIState.activeModal.type === 'admin-panel') {
                        location.reload();
                    } else {
                        LocalUIState.activeModal = null;
                        if (!document.getElementById('app-container').classList.contains('hidden')) {
                            renderAll();
                        }
                    }
                },
                'close-skill-editor': () => {
                    playSound('cancel');
                    const { charIndex } = LocalUIState.activeModal.data;
                    LocalUIState.activeModal = {
                        type:'edit-character',
                        data:{ character: AppState.party[charIndex], charIndex }
                    };
                    renderModal();
                },
                'close-modal-backdrop': () => { if(e.target.classList.contains('modal-backdrop') && !['edit-skill', 'edit-character', 'delete-confirm', 'edit-preset-item', 'confirm', 'admin-panel', 'admin-prompt', 'high-roll-prompt', 'spell-library', 'skill-library-picker'].includes(LocalUIState.activeModal?.type) ) localActions['close-modal'](); },
                'edit-character': () => { playSound('confirm'); LocalUIState.activeModal = {type:'edit-character', data:{character:AppState.party[cIndex], charIndex:cIndex}}; renderModal(); },
                'edit-mode-toggle': () => { playSound('confirm'); LocalUIState.isEditMode = !LocalUIState.isEditMode; if (!LocalUIState.isEditMode) { LocalUIState.activeMenus = Array(4).fill(null).map(() => ({path: []})); } renderAll(); },
                'copy-party-id': () => { const textToCopy = partyId; const textArea = document.createElement("textarea"); textArea.value = textToCopy; textArea.style.position = "fixed"; textArea.style.left = "-9999px"; document.body.appendChild(textArea); textArea.select(); try { document.execCommand('copy'); const p = e.target; const originalText = p.textContent; p.textContent = "Copied!"; p.style.color = 'var(--hp-color)'; setTimeout(() => { p.textContent = originalText; p.style.color = ''; }, 1500); } catch (err) { console.error('Fallback copy failed', err); } document.body.removeChild(textArea); },
                'leave-session-prompt': () => { LocalUIState.activeModal = { type: 'confirm', data: { title: 'Leave Session', message: 'This will return you to the main menu. You can rejoin later if you have the Party ID. Proceed?', confirmAction: 'confirm-leave-session', confirmText: 'Leave' } }; renderModal(); },
                'confirm-leave-session': () => handleLeaveSession(true),
                'delete-party-prompt': () => { LocalUIState.activeModal = { type: 'confirm', data: { title: 'Delete Party', message: 'Are you sure you want to PERMANENTLY delete this party for everyone? This action cannot be undone.', confirmAction: 'confirm-delete-party', confirmText: 'Delete Forever', confirmClass: 'text-red-500' } }; renderModal(); },
                'confirm-delete-party': () => handleDeleteParty(),
                'reset-offline-prompt': () => { LocalUIState.activeModal = { type: 'confirm', data: { title: 'Reset Offline Data', message: 'Are you sure you want to delete all offline data? This action cannot be undone.', confirmAction: 'confirm-reset-offline', confirmText: 'Reset', confirmClass: 'text-red-500' } }; renderModal(); },
                'confirm-reset-offline': () => { localStorage.removeItem('fabulaUltimaPartySheet'); location.reload(); },
                'import-data': () => document.getElementById('import-file-input').click(),
                'export-data': () => { playSound('confirm'); const date = new Date(); const dateString = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getDate().toString().padStart(2, '0')}`; const dataToExport = isOfflineMode ? { ...AppState, localSettings: LocalUIState.settings } : AppState; const a = document.createElement('a'); a.href = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(dataToExport, null, 2)); a.download = `${dateString}_fabula_ultima_party.json`; a.click(); },
                'import-character': () => document.getElementById(`character-import-${cIndex}`).click(),
                'export-character': () => { playSound('confirm'); const char = AppState.party[cIndex]; const date = new Date(); const dateString = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getDate().toString().padStart(2, '0')}`; const charData = JSON.stringify(char, null, 2); const a = document.createElement('a'); a.href = "data:text/json;charset=utf-8," + encodeURIComponent(charData); a.download = `${dateString}_${char.name.replace(/\s/g, '_')}_fabula_ultima.json`; a.click(); },
                'upload-portrait': () => document.getElementById(`portrait-upload-${cIndex}`).click(),
                'use-item': () => {
                    const user = AppState.party[cIndex];
                    let item;
                    const findItem = (items) => { for (const i of items) { if (i.name === data.itemName) { item = i; return true; } if (i.items && findItem(i.items)) return true; } return false; };
                    findItem(user.commands);
                    if (!item) return;

                    let canAfford = true;
                    if (item.costType === '1/3 Current HP') {
                        const cost = Math.floor(user.stats.hp.current / 3);
                        if (user.stats.hp.current <= cost) canAfford = false;
                    } else if (item.costType !== 'None') {
                        const resLC = item.costType.toLowerCase();
                        if (user.stats[resLC].current < item.costValue) canAfford = false;
                    }
                    if (!canAfford) { playSound('error'); return; }

                    if (item.name === 'Magic Tent') { sharedActions['use-magic-tent'](user); return; }

                    if (item.targeting === 'Self') {
                        applyAbilityEffect(user, item, [cIndex]);
                        return;
                    }
                    if (item.targeting === 'All Targets') {
                        const targets = AppState.party.map((_, i) => i);
                        applyAbilityEffect(user, item, targets);
                    } else if (item.targeting === 'All Allies') {
                        const targets = AppState.party.map((_, i) => i).filter(i => i !== cIndex);
                        applyAbilityEffect(user, item, targets);
                    } else if (item.targeting === '1 Target') {
                        const cureStatusEffect = item.effects.find(e => e.type === 'cureStatus' && e.status === 'any');
                        if (cureStatusEffect) {
                            const partyWithStatus = AppState.party.map((p, i) => ({...p, originalIndex: i})).filter(p => Object.values(p.status).some(s => s));
                            if (partyWithStatus.length === 0) { playSound('error'); return; }
                            LocalUIState.activeModal = { type: 'tonic-target-selection', data: { item, userCharIndex: cIndex, partyWithStatus } };
                        } else {
                            LocalUIState.activeModal = {type:'target-selection', data:{item, userCharIndex: cIndex}};
                        }
                        renderModal();
                    } else { // Multi-target
                        LocalUIState.activeModal = {type:'target-selection-multi', data:{item, userCharIndex: cIndex, selectedTargets: []}};
                        renderModal();
                    }
                },
                'select-tonic-target': () => {
                    const { item, userCharIndex } = LocalUIState.activeModal.data;
                    LocalUIState.activeModal = { type: 'cure-status', data: { item, userCharIndex, targetCharIndex: parseInt(data.targetCharIndex) } };
                    renderModal();
                },
                'select-multi-target': () => {
                    const { item, selectedTargets } = LocalUIState.activeModal.data;
                    const maxTargetsMatch = item.targeting.match(/\d+/);
                    const maxTargets = maxTargetsMatch ? parseInt(maxTargetsMatch[0]) : 1;
                    const targetIndex = parseInt(data.targetCharIndex);
                    const indexInSelection = selectedTargets.indexOf(targetIndex);
                    if (indexInSelection > -1) {
                        selectedTargets.splice(indexInSelection, 1);
                    } else {
                        if(selectedTargets.length < maxTargets) {
                            selectedTargets.push(targetIndex);
                        } else {
                            playSound('error');
                        }
                    }
                    renderModal();
                },
                'edit-item': () => {
                    playSound('confirm');
                    const { charIndex } = LocalUIState.activeModal.data;
                    const pathArr = data.path ? data.path.split(',').map(Number) : [];
                    const { item } = _getItemAndParentByPath(AppState.party[charIndex].commands, pathArr);
                    if (!item) return;

                    const modalData = { item: JSON.parse(JSON.stringify(item)), itemPath: pathArr, isNew: false };
                    LocalUIState.activeModal.type = 'edit-skill';
                    LocalUIState.activeModal.data = { ...LocalUIState.activeModal.data, ...modalData };
                    renderModal();
                },
                'edit-item-from-detail': () => {
                    playSound('confirm');
                    const { item, charIndex } = LocalUIState.activeModal.data;
                    const findPath = (items, name, currentPath) => {
                        for (let i = 0; i < items.length; i++) {
                            const path = [...currentPath, i];
                            if (items[i].name === name) return path;
                            if (items[i].items) {
                                const result = findPath(items[i].items, name, path);
                                if (result) return result;
                            }
                        }
                        return null;
                    };
                    const itemPath = findPath(AppState.party[charIndex].commands, item.name, []);
                    if (!itemPath) { playSound('error'); return; }
                    
                    LocalUIState.activeModal = {
                        type: 'edit-skill',
                        data: {
                            charIndex: charIndex,
                            character: AppState.party[charIndex],
                            item: JSON.parse(JSON.stringify(item)),
                            itemPath: itemPath,
                            isNew: false
                        }
                    };
                    renderModal();
                },
                'add-item': () => {
                    playSound('confirm');
                    const { charIndex } = LocalUIState.activeModal.data;
                    const pathArr = data.path ? data.path.split(',').map(Number) : [];
                    if (data.type === 'item') {
                        LocalUIState.activeModal = {
                            type: 'skill-library-picker',
                            data: { 
                                ...LocalUIState.activeModal.data,
                                parentPath: pathArr,
                            }
                        };
                        renderModal();
                        document.getElementById('skill-library-search')?.focus();
                        return;
                    }
                    // For categories
                    LocalUIState.activeModal.type = 'edit-skill';
                    LocalUIState.activeModal.data.item = {};
                    LocalUIState.activeModal.data.itemPath = pathArr;
                    LocalUIState.activeModal.data.newType = data.type;
                    LocalUIState.activeModal.data.isNew = true;
                    renderModal();
                },
                'delete-item': () => {
                    playSound('error');
                    const { charIndex } = LocalUIState.activeModal.data;
                    const pathArr = (data.path ? data.path.split(',') : LocalUIState.activeModal.data.itemPath).map(Number);
                    const { item: itemToDelete } = _getItemAndParentByPath(AppState.party[charIndex].commands, pathArr);
                    if (!itemToDelete) return;

                    LocalUIState.activeModal = {
                        type: 'delete-confirm',
                        data: { ...LocalUIState.activeModal.data, itemPath: pathArr, itemName: itemToDelete.name, itemType: itemToDelete.type }
                    };
                    renderModal();
                },
                'add-effect': () => {
                     const item = LocalUIState.activeModal.data.item;
                     item.name = document.getElementById('skill-edit-name').value;
                     item.costType = document.getElementById('skill-edit-cost-type').value;
                     item.costValue = parseInt(document.getElementById('skill-edit-cost-value').value) || 0;
                     item.targeting = document.getElementById('skill-edit-targeting').value;
                     item.upTo = document.getElementById('skill-edit-up-to').checked;
                     item.doesNotStack = document.getElementById('skill-edit-does-not-stack').checked;
                     item.effect = document.getElementById('skill-edit-effect').value;
                    
                    const content = `
                        <div class="modal-backdrop" data-action="close-add-effect-menu">
                            <div class="jrpg-window w-11/12 max-w-sm">
                                <h3 class="text-yellow-300 mb-2">Select Effect Type</h3>
                                <div class="grid grid-cols-2 gap-2">
                                    ${Object.entries(EFFECT_TYPES).map(([type, {name}]) => `<button class="jrpg-window !p-2 action-button" data-action="select-effect-type" data-type="${type}">${name}</button>`).join('')}
                                </div>
                            </div>
                        </div>`;
                    document.getElementById('modal-container').insertAdjacentHTML('beforeend', content);
                },
                'close-add-effect-menu': () => {
                    e.target.remove();
                },
                'select-effect-type': () => {
                    e.target.closest('.modal-backdrop').remove();
                    const effectType = data.type;
                    LocalUIState.activeModal.data.editingEffect = {
                        effect: { type: effectType },
                        index: -1
                    };
                    renderModal();
                },
                'edit-effect': () => {
                    const item = LocalUIState.activeModal.data.item;
                    const index = parseInt(data.index);
                     item.name = document.getElementById('skill-edit-name').value;
                     item.costType = document.getElementById('skill-edit-cost-type').value;
                     item.costValue = parseInt(document.getElementById('skill-edit-cost-value').value) || 0;
                     item.targeting = document.getElementById('skill-edit-targeting').value;
                     item.upTo = document.getElementById('skill-edit-up-to').checked;
                     item.doesNotStack = document.getElementById('skill-edit-does-not-stack').checked;
                     item.effect = document.getElementById('skill-edit-effect').value;

                    if (item && item.effects && item.effects[index]) {
                        LocalUIState.activeModal.data.editingEffect = {
                            effect: JSON.parse(JSON.stringify(item.effects[index])),
                            index: index
                        };
                        renderModal();
                    }
                },
                'cancel-edit-effect': () => {
                    delete LocalUIState.activeModal.data.editingEffect;
                    renderModal();
                },
                'cancel-edit-effect-backdrop': () => {
                     if (e.target.classList.contains('modal-backdrop')) {
                        delete LocalUIState.activeModal.data.editingEffect;
                        renderModal();
                    }
                },
                'confirm-high-roll': () => {
                    const hr = parseInt(document.getElementById('high-roll-input').value) || 0;
                    if(LocalUIState.activeModal.data.onConfirm) {
                        LocalUIState.activeModal.data.onConfirm(hr);
                    }
                },
                'admin-join-session': () => { joinParty(data.partyId); },
                'admin-delete-session-prompt': () => {
                    LocalUIState.activeModal = {
                        type: 'confirm',
                        data: {
                            title: 'Admin Delete Session',
                            message: `Permanently delete session: ${data.partyId}?`,
                            confirmAction: 'confirm-admin-delete',
                            confirmText: 'Delete',
                            confirmClass: 'text-red-500',
                            partyId: data.partyId
                        }
                    };
                    renderModal();
                },
                'confirm-admin-delete': async () => {
                    try {
                        await db.collection('parties').doc(data.partyId).delete();
                        handleJoinParty();
                    } catch (error) {
                        LocalUIState.activeModal.data.error = error.message;
                        renderModal();
                    }
                },
            };
            
            if (sharedActions[action]) {
                sharedActions[action]();
            } else if (localActions[action]) {
                localActions[action]();
            }
        }
        
        // --- SOUND & MISC HELPERS ---
        
        function initializeSounds() {if (soundInitialized) return; soundInitialized = true; if (typeof Tone === 'undefined') { console.error("Tone.js library not found."); return; } try { volumeNode = new Tone.Volume(Tone.gainToDb(LocalUIState.settings.volume)).toDestination(); volumeNode.mute = LocalUIState.settings.muted; sounds = { navigate: new Tone.Synth({ oscillator: { type: "fmsquare", harmonicity: 0.5 }, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 } }).connect(volumeNode), confirm: new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 } }).connect(volumeNode), select: new Tone.Synth({ oscillator: { type: "triangle", }, envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 } }).connect(volumeNode), cancel: new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.3, sustain: 0, release: 0.3 } }).connect(volumeNode), error: new Tone.Synth({ oscillator: { type: "sawtooth" }, envelope: { attack: 0.01, decay: 0.5, sustain: 0, release: 0.1 } }).connect(volumeNode), healParty: new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'triangle' }, envelope: { attack: 0.005, decay: 0.2, sustain: 0.1, release: 0.2 } }).connect(volumeNode), info: new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.2 } }).connect(volumeNode) }; } catch (e) { console.error("Could not initialize Tone.js sounds.", e); sounds = null; }}
        function playSound(sound) {if (!soundInitialized) initializeSounds(); if (!sounds) return; if (Tone.context.state !== 'running') { Tone.start().catch(e => console.error("Tone.js start failed:", e)); } const soundMap = { 'navigate': 'A4', 'confirm': 'C6', 'select': 'G3', 'cancel': 'G4', 'error': 'C2', 'info': 'G5' }; if (sound === 'healParty') { const now = Tone.now(); sounds.healParty.triggerAttackRelease(["C5", "E5", "G5", "C6"], "8n", now); } else if (sounds[sound]) { sounds[sound].triggerAttackRelease(soundMap[sound], "8n"); }}
        
        function addModalEventListeners(type, data) {
            if (type === 'system-menu') {
                document.getElementById('volume-slider').addEventListener('input', (e) => {
                    LocalUIState.settings.volume = parseFloat(e.target.value);
                    if(volumeNode) volumeNode.volume.value = Tone.gainToDb(LocalUIState.settings.volume);
                    if(isOfflineMode) saveData();
                });
                document.getElementById('mute-btn').addEventListener('click', (e) => {
                    LocalUIState.settings.muted = !LocalUIState.settings.muted;
                    if(volumeNode) volumeNode.mute = LocalUIState.settings.muted;
                    e.target.textContent = LocalUIState.settings.muted ? 'Unmute' : 'Mute';
                    if(isOfflineMode) saveData();
                });
                document.getElementById('import-file-input').addEventListener('change', (e) => {
                    if (!e.target.files[0]) return;
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const imported = JSON.parse(event.target.result);
                            if (imported.party) {
                                AppState.party = imported.party;
                                AppState.settings = imported.settings || { backgroundUrl: '' };
                                if (imported.localSettings) LocalUIState.settings = imported.localSettings;
                                LocalUIState.activeModal = null;
                                renderAll();
                                saveData();
                                playSound('confirm');
                            }
                        } catch (err) {
                            playSound('error');
                        }
                    };
                    reader.readAsText(e.target.files[0]);
                });
            } else if (type === 'edit-character'){
                setupDragAndDrop(data.charIndex);
                const charIndex = data.charIndex;
                document.getElementById(`portrait-upload-${charIndex}`).addEventListener('change', e => {
                    if(e.target.files[0]) {
                        resizeImage(e.target.files[0], 150, 150, (resizedDataUrl) => {
                            AppState.party[charIndex].portrait = resizedDataUrl;
                            saveData();
                        });
                    }
                });
                document.querySelectorAll('input[data-path], select[data-path]').forEach(el => {
                    el.addEventListener('change', e => {
                        const path = e.target.dataset.path;
                        let value = e.target.type === 'number' ? parseInt(e.target.value) || 0 : e.target.value;
                        let obj = AppState.party[charIndex];
                        const keys = path.split('.');
                        keys.forEach((key, i) => {
                            if (i === keys.length - 1) { obj[key] = value; } else { obj = obj[key]; }
                        });
                        saveData();
                    });
                });
                 document.getElementById(`character-import-${charIndex}`).addEventListener('change', e => {
                    if (!e.target.files[0]) return;
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const importedChar = JSON.parse(event.target.result);
                            if (importedChar.name && importedChar.stats) { // Simplified check
                                const originalId = AppState.party[charIndex].id;
                                const newChar = buildCharacterFromImport(importedChar);
                                AppState.party[charIndex] = newChar;
                                AppState.party[charIndex].id = originalId;
                                computeCharacterStats(AppState.party[charIndex]);
                                saveData();
                                playSound('confirm');
                                LocalUIState.activeModal.data.character = AppState.party[charIndex];
                                renderModal();
                            } else { playSound('error'); }
                        } catch (err) { playSound('error'); }
                    };
                    reader.readAsText(e.target.files[0]);
                });

                if (data.autoOpenPath) {
                    const event = new MouseEvent('click', { bubbles: true, cancelable: true });
                    document.querySelector(`[data-action="edit-item"][data-path="${data.autoOpenPath.join(',')}"]`)?.dispatchEvent(event);
                }

            } else if (type === 'adjust-stat') {
                const input = document.getElementById('adjust-value');
                input.focus();
                input.select();
                input.addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); document.querySelector('[data-action="confirm-adjust-stat"][data-op="add"]').click(); }});
            } else if (type === 'admin-prompt' || type === 'high-roll-prompt') {
                const input = document.querySelector('.modal-backdrop input[type="number"], .modal-backdrop input[type="password"]');
                input.focus();
                input.select();
                input.addEventListener('keydown', e => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        input.closest('.jrpg-window').querySelector('[data-action^="confirm-"], [data-action^="submit-"]').click();
                    }
                });
            } else if (type === 'skill-library-picker') {
                const searchInput = document.getElementById('skill-library-search');
                searchInput.focus();
                searchInput.addEventListener('input', e => {
                    LocalUIState.activeModal.data.searchTerm = e.target.value;
                    renderModal();
                    document.getElementById('skill-library-search').focus();
                });
            }
        }

        function safeEval(formula) {
            try {
                // Only allow numbers, attributes, HR, HP_COST and basic math operators
                if (/[^0-9a-zA-Z_+\-*/(). ]/.test(formula)) {
                    console.error("Invalid characters in formula:", formula);
                    return 0;
                }
                return new Function('return ' + formula)();
            } catch (e) {
                console.error("Error evaluating formula:", formula, e);
                return 0;
            }
        }

        async function applyAbilityEffect(userChar, ability, targetCharIndices, highRoll = null) {
            const userCharIndex = AppState.party.findIndex(p => p.id === userChar.id);
            let costPaid = false;
            let hpCost = 0;
            if (ability.costType === '1/3 Current HP') {
                const cost = Math.floor(userChar.stats.hp.current / 3);
                if (userChar.stats.hp.current > cost) {
                    hpCost = cost;
                    costPaid = true; 
                }
            } else if (ability.costType !== 'None') {
                const resLC = ability.costType.toLowerCase();
                if (userChar.stats[resLC].current >= ability.costValue) {
                    costPaid = true;
                }
            } else {
                costPaid = true;
            }

            if (!costPaid) { playSound('error'); return; }

            const manualDamageEffect = ability.effects.find(e => e.type === 'damage' && e.calculation === 'manual');
            if (manualDamageEffect && highRoll === null) {
                LocalUIState.activeModal = { type: 'high-roll-prompt', data: {
                    onConfirm: (hr) => {
                        LocalUIState.activeModal = null; // Close prompt before applying effect
                        applyAbilityEffect(userChar, ability, targetCharIndices, hr);
                    }
                } };
                renderModal();
                return;
            }
            
            if (ability.costType === '1/3 Current HP') {
                userChar.stats.hp.current -= hpCost;
            } else if (ability.costType !== 'None') {
                userChar.stats[ability.costType.toLowerCase()].current -= ability.costValue;
            }

            let opensCureModal = false;
            targetCharIndices.forEach(targetCharIndex => {
                const targetChar = AppState.party[targetCharIndex];
                (ability.effects || []).forEach(effect => {
                    switch (effect.type) {
                        case 'healing':
                        case 'resourceLoss': {
                            const stat = effect.stat.toLowerCase();
                             const formula = effect.value.replace(/\[\[(\w+)\]\]/g, '$1')
                                .replace(/DEX|INS|MIG|WLP/g, (match) => {
                                    const { die } = getAttributeDisplayInfo(userChar, match);
                                    return parseInt(die.slice(1));
                                });
                            const value = Math.max(0, safeEval(formula));
                            if(effect.type === 'healing') {
                                targetChar.stats[stat].current = Math.min(targetChar.stats[stat].max, targetChar.stats[stat].current + value);
                            } else {
                                targetChar.stats[stat].current = Math.max(0, targetChar.stats[stat].current - value);
                            }
                            break;
                        }
                        case 'damage': {
                            let value = 0;
                            const formula = effect.value.replace(/\[\[(\w+)\]\]/g, '$1')
                                .replace(/HR/g, highRoll || 0)
                                .replace(/HP_COST/g, hpCost)
                                .replace(/DEX|INS|MIG|WLP/g, (match) => {
                                    const { die } = getAttributeDisplayInfo(userChar, match);
                                    return parseInt(die.slice(1));
                                });
                            value = Math.max(0, safeEval(formula));
                            
                            let finalDamage = value;
                            // Check for target affinities
                            const targetAffinities = targetChar.computedAffinities || {};
                            const affinity = targetAffinities[effect.damageType];
                            if (affinity === 'Vulnerability') finalDamage *= 2;
                            if (affinity === 'Resistance' && !effect.ignoresResistance) finalDamage = Math.floor(finalDamage / 2);
                            if (affinity === 'Immunity' && !effect.ignoresResistance) finalDamage = 0;
                            if (affinity === 'Absorption') finalDamage = -value; // Negative damage for healing
                            
                            targetChar.stats.hp.current = Math.max(0, targetChar.stats.hp.current - finalDamage);
                            if (finalDamage < 0) { // Absorption healing
                                targetChar.stats.hp.current = Math.min(targetChar.stats.hp.max, targetChar.stats.hp.current - finalDamage);
                            }
                            break;
                        }
                        case 'inflictStatus':
                            if (targetChar.status.hasOwnProperty(effect.status)) {
                                targetChar.status[effect.status] = true;
                            }
                            break;
                        case 'cureStatus':
                            if (effect.status === 'any') {
                                const hasStatus = Object.values(targetChar.status).some(s => s);
                                if (hasStatus) {
                                    opensCureModal = true;
                                    LocalUIState.activeModal = { type: 'cure-status', data: { item: ability, userCharIndex, targetCharIndex } };
                                }
                            } else if (targetChar.status.hasOwnProperty(effect.status)) {
                                targetChar.status[effect.status] = false;
                            }
                            break;
                         case 'attributeModification': {
                            if (ability.doesNotStack) {
                                const existingEffect = targetChar.temporaryEffects.find(eff => eff.source === ability.name && eff.attribute === effect.attribute);
                                if (existingEffect) break; // Don't apply if it already exists
                            }
                            const { attribute, modification, amount, duration } = effect;
                            const tempEffect = {
                                type: 'attributeModification',
                                attribute,
                                amount: modification === 'increase' ? amount : -amount,
                                duration,
                                source: ability.name,
                            };
                            targetChar.temporaryEffects.push(tempEffect);
                            break;
                        }
                        case 'misc': {
                             if (ability.doesNotStack) {
                                const existingEffect = targetChar.temporaryEffects.find(eff => eff.source === ability.name);
                                if (existingEffect) break;
                            }
                            const { description, duration } = effect;
                             const tempEffect = {
                                type: 'misc',
                                description,
                                duration,
                                source: ability.name,
                            };
                            targetChar.temporaryEffects.push(tempEffect);
                            break;
                        }
                        case 'dispel': {
                            targetChar.temporaryEffects = [];
                            break;
                        }
                    }
                });
            });
            
            playSound('confirm');
            
            if(!opensCureModal) LocalUIState.activeModal = null;
            
            saveData();
            
            if (isOfflineMode) renderAll();
             else if (!opensCureModal) renderAll();
        }

        function createDefaultCharacter(id) {
            const character = {
                id,
                name: `Hero ${id + 1}`,
                portrait: `https://placehold.co/100x100/1a1a5c/ffffff?text=P${id + 1}`,
                stats: { hp: { current: 50, max: 50 }, mp: { current: 20, max: 20 }, ip: { current: 6, max: 6 } },
                def: 10,
                mdef: 10,
                attributes: { DEX: 'd6', INS: 'd6', MIG: 'd6', WLP: 'd6' },
                status: { slow: false, dazed: false, weak: false, shaken: false, poisoned: false, enraged: false },
                temporaryEffects: [],
                commands: [
                    { name: 'Attack', type: 'category', isCollapsed: false, items: [
                        { name: 'Basic Attack', type: 'item', targeting: '1 Target', upTo: false, doesNotStack: true, costType: 'None', costValue: 0, effect: '[[MIG]] vs Defense.', effects: [{type: 'damage', value: 'HR+MIG', damageType: 'Physical', calculation: 'manual'}] }
                    ]},
                    { name: 'Magic', type: 'category', isCollapsed: false, items: [
                        { name: 'Fire', type: 'item', targeting: '1 Target', upTo: false, doesNotStack: true, costType: 'MP', costValue: 5, effect: 'Deals minor Fire damage.', effects: [{type: 'damage', value: '10', damageType: 'Fire', calculation: 'auto'}] }
                    ]},
                    { name: 'Skills', type: 'category', isCollapsed: false, items: [
                        { name: 'Blood Blade', type: 'item', targeting: '1 Target', upTo: false, doesNotStack: true, costType: '1/3 Current HP', costValue: 0, effect: 'Deals damage equal to HP spent.', effects: [{type: 'damage', value: 'HP_COST', damageType: 'Physical', calculation: 'auto'}] }
                    ]},
                    { name: 'Items', type: 'category', isCollapsed: false, items: [
                        { name: 'Remedy', type: 'item', targeting: '1 Target', upTo: false, doesNotStack: true, costType: 'IP', costValue: 3, effect: 'Recover 50 HP.', effects: [{type: 'healing', stat: 'HP', value: '50'}] },
                        { name: 'Elixir', type: 'item', targeting: '1 Target', upTo: false, doesNotStack: true, costType: 'IP', costValue: 3, effect: 'Recover 50 MP.', effects: [{type: 'healing', stat: 'MP', value: '50'}] },
                        { name: 'Tonic', type: 'item', targeting: '1 Target', upTo: false, doesNotStack: true, costType: 'IP', costValue: 2, effect: 'Cure one status effect.', effects: [{type: 'cureStatus', status: 'any'}] },
                        { name: 'Magic Tent', type: 'item', targeting: 'All Allies', upTo: false, doesNotStack: true, costType: 'IP', costValue: 4, effect: 'Fully rest.', effects: [] },
                    ] },
                ],
                customization: { categoryColor: '#ffff00', itemColor: '#ffffff', nameColor: '#ffff00' }
            };

            if (id === 0) {
                character.attributes = { DEX: 'd10', INS: 'd10', MIG: 'd10', WLP: 'd10' };
                character.commands.push({ name: 'Test Skills', type: 'category', isCollapsed: false, items: [
                    { name: 'Test Fire', type: 'item', targeting: '1 Target', upTo: false, doesNotStack: true, costType: 'MP', costValue: 1, effect: 'Test Fire Damage', effects: [{type: 'damage', value: 'WLP+5', damageType: 'Fire', calculation: 'auto'}] },
                    { name: 'Test Ice All', type: 'item', targeting: 'All Allies', upTo: false, doesNotStack: true, costType: 'MP', costValue: 1, effect: 'Test Ice Damage All Allies', effects: [{type: 'damage', value: '15', damageType: 'Ice', calculation: 'auto'}] },
                    { name: 'Test Manual', type: 'item', targeting: '1 Target', upTo: false, doesNotStack: true, costType: 'None', costValue: 0, effect: 'Test Manual Damage', effects: [{type: 'damage', value: 'HR+MIG', damageType: 'Physical', calculation: 'manual'}] },
                    { name: 'Test Weaken', type: 'item', targeting: '1 Target', upTo: false, doesNotStack: true, costType: 'None', costValue: 0, effect: 'Test Inflict Weak', effects: [{type: 'inflictStatus', status: 'weak'}] },
                    { name: 'Empower', type: 'item', targeting: 'Self', upTo: false, doesNotStack: true, costType: 'None', costValue: 0, effect: 'Increase MIG by 1 die step.', effects: [{type: 'attributeModification', attribute: 'MIG', modification: 'increase', amount: 1, duration: 'scene'}] },
                    { name: 'Dispel', type: 'item', targeting: '1 Target', upTo: false, doesNotStack: true, costType: 'MP', costValue: 10, effect: 'Removes temporary magical effects.', effects: [{type: 'dispel', targetEffects: 'all'}] },
                ]});
            }
            return character;
        }

        function renderAffinities(char) {
            const affinities = char.computedAffinities || {};
            if (Object.keys(affinities).length === 0) return 'None';
            
            return Object.entries(affinities).map(([type, value]) => {
                const damageData = DAMAGE_TYPE_DATA[type] || {};
                let affinityText = '';
                switch(value) {
                    case 'Resistance': affinityText = 'Resist'; break;
                    case 'Vulnerability': affinityText = 'Vulnerable'; break;
                    case 'Immunity': affinityText = 'Immune'; break;
                    case 'Absorption': affinityText = 'Absorb'; break;
                    default: affinityText = value;
                }
                return `<span class="inline-flex items-center mr-2" style="color: ${damageData.color};">${affinityText} ${type}</span>`;
            }).join('');
        }

        function setupMarqueeListeners() {
            document.getElementById('app-container').addEventListener('mouseover', (e) => {
                const skillNameContainer = e.target.closest('.truncate-on-hover');
                if (skillNameContainer) {
                    const textSpan = skillNameContainer.querySelector('span');
                    if (textSpan && skillNameContainer.offsetWidth < textSpan.scrollWidth && !skillNameContainer._animation) {
                        const originalText = textSpan.textContent;
                        skillNameContainer._originalText = originalText;
                        const separator = " \u00A0\u00A0\u00A0 ";
                        textSpan.textContent = originalText + separator + originalText;

                        const scrollDistance = textSpan.scrollWidth / 2;
                        const duration = scrollDistance * 20;
                        
                        const animation = textSpan.animate([
                            { transform: 'translateX(0)' },
                            { transform: `translateX(-${scrollDistance}px)` }
                        ], {
                            duration: duration,
                            delay: 0,
                            iterations: Infinity,
                            easing: 'linear'
                        });
                        skillNameContainer._animation = animation;
                    }
                }
            });
            document.getElementById('app-container').addEventListener('mouseout', (e) => {
                const skillNameContainer = e.target.closest('.truncate-on-hover');
                 if (skillNameContainer && skillNameContainer._animation) {
                    skillNameContainer._animation.cancel();
                    skillNameContainer._animation = null;
                    const textSpan = skillNameContainer.querySelector('span');
                    if(textSpan && skillNameContainer._originalText) {
                        textSpan.textContent = skillNameContainer._originalText;
                    }
                }
            });
        }
        function buildCharacterFromImport(importedChar) {
            const newChar = createDefaultCharacter(0); // Start with a base template
            
            // Basic Info
            newChar.name = importedChar.name;
            newChar.stats = importedChar.stats;
            newChar.attributes = { // Map attributes from JSON
                DEX: `d${importedChar.attributes.dexterity}`,
                INS: `d${importedChar.attributes.insight}`,
                MIG: `d${importedChar.attributes.might}`,
                WLP: `d${importedChar.attributes.willpower}`
            };
            newChar.lvl = importedChar.lvl;
            newChar.classes = importedChar.classes; // Keep the raw class/skill list for computation
            newChar.commands = []; // We will rebuild this from the library
            newChar.affinities = importedChar.affinities; // Keep raw affinities for computation

            const skillCategory = { name: 'Skills', type: 'category', isCollapsed: false, items: [] };
            const spellCategory = { name: 'Magic', type: 'category', isCollapsed: false, items: [] };

            (importedChar.classes || []).forEach(c => {
                const classData = FU_SKILL_LIBRARY.classes[c.name];
                if (!classData) return;

                (c.skills || []).forEach(s => {
                    const skillData = classData.skills.find(libSkill => libSkill.name === s.skillName);
                    if (skillData && skillData.type !== 'passive') {
                        skillCategory.items.push(JSON.parse(JSON.stringify(skillData)));
                    }
                });

                (c.spells || []).forEach(spell => {
                    const spellData = FU_SKILL_LIBRARY.spells[spell.name];
                     if (spellData) {
                        spellCategory.items.push(JSON.parse(JSON.stringify(spellData)));
                    }
                });
            });

            if(skillCategory.items.length > 0) newChar.commands.push(skillCategory);
            if(spellCategory.items.length > 0) newChar.commands.push(spellCategory);
            
            // You can add back default items, attacks etc. here if desired
            newChar.commands.push({ name: 'Items', type: 'category', isCollapsed: false, items: [
                { name: 'Remedy', type: 'item', targeting: '1 Target', upTo: false, doesNotStack: true, costType: 'IP', costValue: 3, effect: 'Recover 50 HP.', effects: [{type: 'healing', stat: 'HP', value: '50'}] },
                { name: 'Elixir', type: 'item', targeting: '1 Target', upTo: false, doesNotStack: true, costType: 'IP', costValue: 3, effect: 'Recover 50 MP.', effects: [{type: 'healing', stat: 'MP', value: '50'}] },
                { name: 'Tonic', type: 'item', targeting: '1 Target', upTo: false, doesNotStack: true, costType: 'IP', costValue: 2, effect: 'Cure one status effect.', effects: [{type: 'cureStatus', status: 'any'}] },
                { name: 'Magic Tent', type: 'item', targeting: 'All Allies', upTo: false, doesNotStack: true, costType: 'IP', costValue: 4, effect: 'Fully rest.', effects: [] },
            ] });

            return newChar;
        }

        function computeAllCharacterStats() {
            AppState.party.forEach(computeCharacterStats);
        }

        function computeCharacterStats(char) {
            // Reset computed stats
            char.computedAffinities = {};
            const isCrisis = char.stats.hp.current <= Math.floor(char.stats.hp.max / 2);

            // Add affinities from the imported JSON `affinities` object first.
            if(char.affinities) { // This is from the imported JSON format
                const affinityMap = { rs: 'Resistance', vu: 'Vulnerability', im: 'Immunity', ab: 'Absorption' };
                const damageTypeMap = { wind: 'Air', bolt: 'Bolt', dark: 'Dark', earth: 'Earth', fire: 'Fire', ice: 'Ice', light: 'Light', poison: 'Poison', physical: 'Physical' };
                for(const [type, value] of Object.entries(char.affinities)) {
                    const mappedType = damageTypeMap[type];
                    if(mappedType && affinityMap[value]) {
                        char.computedAffinities[mappedType] = affinityMap[value];
                    }
                }
            }

            // Loop through character's classes and skills to apply passive effects
            if (!char.classes) return; // Not an imported character with this structure

            char.classes.forEach(c => {
                const classData = FU_SKILL_LIBRARY.classes[c.name];
                if (!classData) return;
                
                c.skills.forEach(s => {
                    const skillData = classData.skills.find(libSkill => libSkill.name === s.skillName);
                    if (skillData && skillData.type === 'passive') {
                        (skillData.effects || []).forEach(effect => {
                            // Check for conditions before applying the effect
                            let canApply = true;
                            if (effect.condition === 'crisis' && !isCrisis) {
                                canApply = false;
                            }
                            
                            if(canApply) {
                                if (effect.type === 'addAffinity') {
                                    char.computedAffinities[effect.damageType] = effect.affinity;
                                }
                                 if (effect.type === 'statBonus') {
                                     // Placeholder for future stat bonuses like from Defensive Mastery
                                 }
                            }
                        });
                    }
                });
            });
        }
        function getItemsFromPath(char, path) { let currentLevel = char.commands; for (const index of path) { if (currentLevel && currentLevel[index] && currentLevel[index].items) { currentLevel = currentLevel[index].items; } else if (currentLevel && currentLevel[index]) { return currentLevel; } else { return char.commands; } } return currentLevel; }
        function renderStatusPanels() {
            const container = document.getElementById('status-panels');
            container.innerHTML = AppState.party.map((char, index) => {
                const isCrisis = char.stats.hp.current <= Math.floor(char.stats.hp.max / 2);
                return `
                <div id="status-panel-${index}" class="jrpg-window flex flex-col gap-2 p-2">
                    <div class="flex justify-between items-start">
                         <div data-action="open-info-screen" data-char-index="${index}" class="cursor-pointer portrait-container ${isCrisis ? 'crisis' : ''}">
                             <img src="${char.portrait}" alt="${char.name}" class="w-16 h-16 object-cover border-2 border-white flex-shrink-0" onerror="this.src='https://placehold.co/100x100/1a1a5c/ffffff?text=ERR'">
                         </div>
                        <div class="text-right">
                            <div>DEF: ${char.def}</div>
                            <div>M.DEF: ${char.mdef}</div>
                        </div>
                    </div>
                    <div class="space-y-1">
                        ${['hp', 'mp', 'ip'].map(stat => {
                            const s = char.stats[stat];
                            const barColor = (stat === 'hp' && isCrisis) ? 'var(--crisis-color)' : `var(--${stat}-color)`;
                            
                            if (stat === 'hp') {
                                const basePercent = s.max > 0 ? (s.current / s.max) * 100 : 0;
                                const tempPercent = s.current > s.max ? ((s.current - s.max) / s.max) * 100 : 0;
                                const cappedBasePercent = Math.min(basePercent, 100);
                                const cappedTempPercent = Math.min(basePercent - 100, 100);

                                return `<div class="flex items-center gap-2">
                                    <span style="color:${barColor};">HP</span>
                                    <div class="progress-bar-container flex-grow" data-action="adjust-stat" data-char-index="${index}" data-stat="hp">
                                        <div class="progress-bar" style="width:${cappedBasePercent}%; background-color: ${barColor}; z-index: 1;"></div>
                                        ${s.current > s.max ? `<div class="progress-bar" style="width:${cappedTempPercent}%; background-color: var(--hp-temp-color); z-index: 2;"></div>` : ''}
                                    </div>
                                    <span class="w-20 text-right">${s.current}/${s.max}</span>
                                </div>`;
                            }
                            
                            const percent = s.max > 0 ? (s.current / s.max) * 100 : 0;
                            const cappedPercent = Math.min(percent, 100);
                            return `<div class="flex items-center gap-2">
                                <span style="color:${barColor};">${stat.toUpperCase()}</span>
                                <div class="progress-bar-container flex-grow" data-action="adjust-stat" data-char-index="${index}" data-stat="${stat}">
                                    <div class="progress-bar" style="width:${cappedPercent}%; background-color: ${barColor};"></div>
                                </div>
                                <span class="w-20 text-right">${s.current}/${s.max}</span>
                            </div>`;
                        }).join('')}
                    </div>
                     <div class="grid grid-cols-2 gap-x-4 gap-y-1 items-center">
                         ${(() => {
                             const dexInfo = getAttributeDisplayInfo(char, 'DEX');
                             const migInfo = getAttributeDisplayInfo(char, 'MIG');
                             const insInfo = getAttributeDisplayInfo(char, 'INS');
                             const wlpInfo = getAttributeDisplayInfo(char, 'WLP');
                             return `
                                 <div class="flex items-center justify-between"><div><span>DEX<span class="text-gray-400">:</span></span><span class="die-value ${dexInfo.colorClass}">${dexInfo.die}</span></div>${renderStatusIcon(char, index, 'slow')}</div>
                                 <div class="flex items-center justify-between"><div><span>MIG<span class="text-gray-400">:</span></span><span class="die-value ${migInfo.colorClass}">${migInfo.die}</span></div>${renderStatusIcon(char, index, 'weak')}</div>
                                 <div class="flex items-center justify-between"><div><span>INS<span class="text-gray-400">:</span></span><span class="die-value ${insInfo.colorClass}">${insInfo.die}</span></div>${renderStatusIcon(char, index, 'dazed')}</div>
                                 <div class="flex items-center justify-between"><div><span>WLP<span class="text-gray-400">:</span></span><span class="die-value ${wlpInfo.colorClass}">${wlpInfo.die}</span></div>${renderStatusIcon(char, index, 'shaken')}</div>
                             `;
                         })()}
                         <div class="flex items-center justify-center">${renderStatusIcon(char, index, 'enraged')}</div>
                         <div class="flex items-center justify-center">${renderStatusIcon(char, index, 'poisoned')}</div>
                     </div>
                </div>`;
            }).join('');
        }
        function renderStatusIcon(char, charIndex, statusKey) { if (!statusKey || !STATUS_EFFECTS[statusKey]) return '<div></div>'; const status = STATUS_EFFECTS[statusKey]; const isStroked = ['slow', 'dazed', 'weak', 'shaken'].includes(statusKey); return `<div class="status-icon ${char.status[statusKey] ? 'active' : ''} ml-1" style="${char.status[statusKey] ? `background-color:${status.color};` : ''}" title="${status.name}" data-action="toggle-status" data-char-index="${charIndex}" data-status="${statusKey}"> <svg class="w-full h-full" ${isStroked ? 'fill="none" stroke="currentColor" stroke-width="1.5"' : 'fill="currentColor"'} viewBox="0 0 24 24"> <path ${isStroked ? 'stroke-linecap="round" stroke-linejoin="round"' : ''} d="${status.icon}" /> </svg> </div>`; }
        
        function getAttributeDisplayInfo(char, attr) {
            let boostAmount = 0;
            (char.temporaryEffects || []).filter(eff => eff.type === 'attributeModification' && eff.attribute === attr).forEach(eff => {
                boostAmount += eff.amount;
            });

            let penaltyAmount = 0;
            if (char.status.slow && attr === 'DEX') penaltyAmount++;
            if (char.status.dazed && attr === 'INS') penaltyAmount++;
            if (char.status.weak && attr === 'MIG') penaltyAmount++;
            if (char.status.shaken && attr === 'WLP') penaltyAmount++;
            if (char.status.poisoned && (attr === 'MIG' || attr === 'WLP')) penaltyAmount++;
            if (char.status.enraged && (attr === 'DEX' || attr === 'INS')) penaltyAmount++;

            const baseIndex = DICE.indexOf(char.attributes[attr]);
            const finalIndex = Math.max(0, Math.min(DICE.length - 1, baseIndex + boostAmount - penaltyAmount));
            const die = DICE[finalIndex];
            
            let colorClass = '';
            if (boostAmount > 0 && penaltyAmount > 0) colorClass = 'text-orange-400';
            else if (boostAmount > 0) colorClass = 'text-green-400';
            else if (penaltyAmount > 0) colorClass = 'text-red-500';

            return { die, colorClass };
        }

        function formatCost(item) { if (!item.costType || item.costType === 'None') return ''; const costText = item.costType === '1/3 Current HP' ? '1/3 HP' : `${item.costValue} ${item.costType}`; let color = 'white'; switch (item.costType) { case 'HP': case '1/3 Current HP': color = 'var(--crisis-color)'; break; case 'MP': color = 'var(--mp-color)'; break; case 'IP': color = 'var(--ip-color)'; break; } return `<span style="color: ${color};">${costText}</span>`; }
        function setupDragAndDrop(charIndex) { const container = document.getElementById('command-editor-container'); if (!container) return; let draggedElement = null; container.addEventListener('dragstart', e => { const target = e.target.closest('.draggable'); if (!target || target.classList.contains('locked-item')) { e.preventDefault(); return; } draggedElement = target; e.dataTransfer.effectAllowed = 'move'; e.dataTransfer.setData('text/plain', target.dataset.path); setTimeout(() => target.classList.add('dragging'), 0); }); container.addEventListener('dragend', e => { if(draggedElement) { draggedElement.classList.remove('dragging'); draggedElement = null; } clearDragIndicators(); }); const clearDragIndicators = () => { document.querySelectorAll('.drop-indicator').forEach(el => el.style.display = 'none'); document.querySelectorAll('.drop-target-category').forEach(el => el.classList.remove('drop-target-category')); }; container.addEventListener('dragover', e => { e.preventDefault(); const dropTarget = e.target.closest('.draggable-container, .draggable, .drop-zone'); if (!dropTarget || !draggedElement) return; clearDragIndicators(); const rect = dropTarget.getBoundingClientRect(); const isCategory = dropTarget.dataset.type === 'category' || dropTarget.classList.contains('drop-zone'); if (isCategory && e.clientY > rect.top + rect.height * 0.25 && e.clientY < rect.top + rect.height * 0.75) { const draggableContent = dropTarget.classList.contains('draggable') ? dropTarget : dropTarget.querySelector('.draggable'); if(draggableContent) draggableContent.classList.add('drop-target-category'); } else { const container = dropTarget.closest('.draggable-container'); if(container && !container.querySelector('.locked-item')) { const indicator = container.querySelector('.drop-indicator'); if(indicator) indicator.style.display = 'block'; } } }); container.addEventListener('drop', e => { e.preventDefault(); e.stopPropagation(); clearDragIndicators(); const draggedPathStr = e.dataTransfer.getData('text/plain'); const dropTargetContainer = e.target.closest('.draggable-container, .drop-zone'); if (!dropTargetContainer || !draggedPathStr) return; let dropTargetEl; if (dropTargetContainer.classList.contains('drop-zone')) { dropTargetEl = dropTargetContainer; } else { dropTargetEl = dropTargetContainer.querySelector('.draggable'); } if (!dropTargetEl) return; const targetPathStr = dropTargetEl.dataset.path; if (draggedPathStr === targetPathStr) return; if (targetPathStr.startsWith(draggedPathStr) && targetPathStr.length > draggedPathStr.length) { return; } const rect = dropTargetEl.getBoundingClientRect(); const isCategory = dropTargetEl.dataset.type === 'category' || dropTargetEl.classList.contains('drop-zone'); const dropIntoCategory = isCategory && e.clientY > rect.top + rect.height * 0.25 && e.clientY < rect.top + rect.height * 0.75; handleDrop(charIndex, draggedPathStr, targetPathStr, dropIntoCategory); }); }
        function _getItemAndParentByPath(rootItems, path) { if (!path || path.length === 0) { return { parent: rootItems, item: null, index: -1 }; } let parentList = rootItems; let item = null; for (let i = 0; i < path.length; i++) { const index = path[i]; if (!parentList || !parentList[index]) { return { parent: null, item: null, index: -1 }; } if (i === path.length - 1) { item = parentList[index]; return { parent: parentList, item: item, index: index }; } parentList = parentList[index].items; } return { parent: null, item: null, index: -1 }; }
        function handleDrop(charIndex, draggedPathStr, targetPathStr, dropIntoCategory) { const char = AppState.party[charIndex]; const draggedPath = draggedPathStr.split(',').map(Number); const targetPath = (targetPathStr === "") ? [] : targetPathStr.split(',').map(Number); const { parent: sourceList, item: draggedItem, index: draggedIndex } = _getItemAndParentByPath(char.commands, draggedPath); if (!sourceList || !draggedItem) { return; } let targetList, targetIndex; if (dropIntoCategory) { if (targetPath.length === 0) { targetList = char.commands; } else { const { item: targetCategory } = _getItemAndParentByPath(char.commands, targetPath); if (!targetCategory || targetCategory.type !== 'category') { return; } if (!targetCategory.items) targetCategory.items = []; targetList = targetCategory.items; } targetIndex = targetList.length; } else { const { parent: destParent, index: destIndex } = _getItemAndParentByPath(char.commands, targetPath); if (!destParent) { return; } targetList = destParent; targetIndex = destIndex; } const itemToMove = sourceList.splice(draggedIndex, 1)[0]; if (sourceList === targetList && draggedIndex < targetIndex) { targetIndex--; } targetList.splice(targetIndex, 0, itemToMove); saveData(); if(isOfflineMode) { renderModal();} }
        function resizeImage(file, maxWidth, maxHeight, callback) { const reader = new FileReader(); reader.onload = (e) => { const img = new Image(); img.onload = () => { const canvas = document.createElement('canvas'); let width = img.width; let height = img.height; if (width > height) { if (width > maxWidth) { height *= maxWidth / width; width = maxWidth; } } else { if (height > maxHeight) { width *= maxHeight / height; height = maxHeight; } } canvas.width = width; canvas.height = height; const ctx = canvas.getContext('2d'); ctx.drawImage(img, 0, 0, width, height); callback(canvas.toDataURL('image/jpeg', 0.8)); }; img.src = e.target.result; }; reader.readAsDataURL(file); }
        init();
    };
    </script>
</body>
</html>

